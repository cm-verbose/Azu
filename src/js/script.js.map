{"version":3,"file":"script.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAA2D;AACf;AACF;AACM;AACE;AACO;AACA;AACL;AACD;AACE;AACrD;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA,YAAY,0DAAO;AACnB,YAAY,4DAAa;AACzB;AACA;AACA;AACA;AACA,YAAY,+DAAW;AACvB,YAAY,kEAAc;AAC1B,YAAY,mEAAe;AAC3B,YAAY,gEAAY;AACxB,YAAY,2DAAQ;AACpB,YAAY,6DAAU;AACtB,YAAY,kEAAc;AAC1B,YAAY,+DAAY;AACxB;AACA;;;;;;;;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,4BAA4B;AAC9D,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,EAAE;AAC3C,wCAAwC,EAAE;AAC1C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,wBAAwB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,iCAAiC;AACjC;AACA,iCAAiC;AACjC,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,iCAAiC,yDAAyD;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+BAA+B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,aAAa,GAAG,sBAAsB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,yBAAyB;AACnE;AACA;AACA;AACA,+EAA+E;AAC/E;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qEAAqE,kBAAkB,gBAAgB;AACvG,8DAA8D,mBAAmB;AACjF,6EAA6E;AAC7E;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,4BAA4B,EAAE,uBAAuB;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACzWA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,qBAAqB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,eAAe;AACrD,uCAAuC,gBAAgB;AACvD,qCAAqC,cAAc;AACnD,oCAAoC,+BAA+B;AACnE;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;;;;;;;;;;;;;;;AClOA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC7HA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,MAAM;AAC3D;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACrGA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,gBAAgB;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,cAAc;AACnD,uCAAuC,cAAc;AACrD,kCAAkC,yDAAyD;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,cAAc;AACvD,2CAA2C,cAAc;AACzD,sCAAsC,oBAAoB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gBAAgB;AAClD,qCAAqC,UAAU;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,mBAAmB;AACzD,yCAAyC,aAAa;AACtD;AACA;AACA,kCAAkC,oBAAoB;AACtD,qCAAqC,cAAc;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,8CAA8C;AAC3H,sCAAsC,cAAc;AACpD;AACA;AACA;;;;;;;;;;;;;;;AC1HA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0BAA0B;AAC5C;AACA;;;;;;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACoC;AAC7B,8BAA8B,kDAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,YAAY,GAAG;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,0BAA0B;AAC5D;AACA;AACA;AACA;AACA;AACA,8BAA8B,0BAA0B;AACxD;AACA;AACA;AACA;AACA,8BAA8B,0BAA0B;AACxD;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACnDA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iDAAiD;AACzE;AACA;AACA;AACA;AACA,mDAAmD,iBAAiB;AACpE,oFAAoF,iBAAiB;AACrG;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;;;;;;;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,sCAAsC,MAAM,4BAA4B;AACnI,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4BAA4B;AACpD;AACA,gCAAgC,0BAA0B;AAC1D;AACA,4HAA4H,0BAA0B;AACtJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,SAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,UAAU;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,kBAAkB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC5KA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,+CAA+C,sBAAsB;AACrE,0CAA0C,gBAAgB;AAC1D,6CAA6C,sBAAsB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,MAAM;AACzE,8FAA8F,MAAM;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,MAAM;AACxE;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;AC1EA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACqD;AACtC;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,mDAAmD,SAAS;AAC5D;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mDAAmD;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,8DAAe;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,qCAAqC;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,wBAAwB;AACjE;AACA;AACA;AACA;AACA;AACA,qCAAqC,kCAAkC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,wBAAwB;AACpE;AACA;AACA;AACA;AACA;AACA,6CAA6C,6BAA6B;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E;AAC9E,2EAA2E;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qDAAqD;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,aAAa;AACtF;AACA;AACA;AACA;AACA,QAAQ,cAAc;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iBAAiB;AAC7C;AACA,mCAAmC,8BAA8B;AACjE;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AChZA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,sCAAsC;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;UCjHA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;ACNA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uDAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA","sources":["webpack://azu/./src/ts/modules/editor.ts","webpack://azu/./src/ts/modules/functions/context_menu.ts","webpack://azu/./src/ts/modules/functions/document_styles.ts","webpack://azu/./src/ts/modules/functions/editor_functions.ts","webpack://azu/./src/ts/modules/functions/import_export.ts","webpack://azu/./src/ts/modules/functions/interface.ts","webpack://azu/./src/ts/modules/functions/languages/corrector.ts","webpack://azu/./src/ts/modules/functions/languages/french.ts","webpack://azu/./src/ts/modules/functions/settings.ts","webpack://azu/./src/ts/modules/functions/statistics.ts","webpack://azu/./src/ts/modules/functions/storage.ts","webpack://azu/./src/ts/modules/functions/text_correction.ts","webpack://azu/./src/ts/modules/functions/translations.ts","webpack://azu/webpack/bootstrap","webpack://azu/webpack/runtime/define property getters","webpack://azu/webpack/runtime/hasOwnProperty shorthand","webpack://azu/webpack/runtime/make namespace object","webpack://azu/./src/ts/script.ts"],"sourcesContent":["import EditorFunctions from \"./functions/editor_functions\";\nimport Settings from \"./functions/settings\";\nimport Storage from \"./functions/storage\";\nimport Statictics from \"./functions/statistics\";\nimport UserInterface from \"./functions/interface\";\nimport TextCorrection from \"./functions/text_correction\";\nimport DocumentStyles from \"./functions/document_styles\";\nimport Translations from \"./functions/translations\";\nimport ContextMenu from \"./functions/context_menu\";\nimport ImportExport from \"./functions/import_export\";\n/**\n *\n * @description Reprensents the editor itself, instantiates functions under sub-classes\n *\n */\nexport default class Editor {\n    constructor() {\n        this.ini();\n    }\n    /** @description initializes the editor */\n    ini() {\n        new Storage();\n        new UserInterface();\n        this.setEvents();\n    }\n    /** @description Configures editor functions */\n    setEvents() {\n        new ContextMenu();\n        new DocumentStyles();\n        new EditorFunctions();\n        new ImportExport();\n        new Settings();\n        new Statictics();\n        new TextCorrection();\n        new Translations();\n    }\n}\n","/**\n *\n * @description Handles the custom context menu's logic\n *\n */\nexport default class ContextMenu {\n    constructor() {\n        this.contextMenu = document.querySelector(\"#context-menu\");\n        this.contextMenuOptions = document.querySelector(\"#context-menu-options\");\n        this.ctxCover = document.querySelector(\"#main-cover\");\n        this.editor = document.querySelector(\"#editor\");\n        this.instantiateContextMenu();\n    }\n    /** @description instantiates methods to manipulate the context menu */\n    instantiateContextMenu() {\n        document.addEventListener(\"contextmenu\", (e) => {\n            e.preventDefault();\n            this.populateOptions();\n            this.ctxCover.style.display = \"block\";\n            this.contextMenu.style.display = \"block\";\n            this.handleOpenMenu({ x: e.clientX, y: e.clientY });\n        });\n        this.handleCloseMenu();\n    }\n    /** @description handles opening and positionning the menu, and adding events relative to opening the menu */\n    handleOpenMenu(atMousePos) {\n        const escMenuClose = (e) => {\n            if (e.key !== \"Escape\")\n                return;\n            e.preventDefault();\n            this.closeMenu();\n            document.removeEventListener(\"keydown\", escMenuClose);\n        };\n        document.addEventListener(\"keydown\", escMenuClose);\n        setTimeout(() => {\n            this.moveMenu(atMousePos.x, atMousePos.y);\n        });\n    }\n    /** @description move the menu to a specific position */\n    moveMenu(x, y) {\n        const boundingBox = this.contextMenu.getBoundingClientRect();\n        if (x + boundingBox.width > window.innerWidth) {\n            x = window.innerWidth - boundingBox.width;\n        }\n        if (y + boundingBox.height > window.innerHeight) {\n            y = window.innerHeight - boundingBox.height;\n        }\n        this.contextMenu.style.left = `${x}px`;\n        this.contextMenu.style.top = `${y}px`;\n    }\n    /** Closes the menu on exit of the cover */\n    handleCloseMenu() {\n        this.ctxCover.addEventListener(\"click\", () => {\n            this.closeMenu();\n        });\n    }\n    closeMenu() {\n        this.ctxCover.style.display = \"none\";\n        this.contextMenu.style.display = \"none\";\n    }\n    /** @description Appends created options to the context menu */\n    populateOptions() {\n        this.contextMenuOptions.innerHTML = \"\";\n        const options = [\"Copy\", \"Cut\", \"Paste\", \"SelectAll\", \"Refresh\"];\n        options.forEach((option) => {\n            switch (option) {\n                case \"Copy\":\n                    {\n                        const selection = document.getSelection();\n                        if (selection === null || selection.toString().replace(/\\s+/g, \"\").length === 0)\n                            return;\n                    }\n                    break;\n                case \"Cut\": {\n                    const selection = document.getSelection();\n                    const activeElement = document.activeElement;\n                    if (!activeElement ||\n                        selection === null ||\n                        (activeElement !== this.editor && activeElement.tagName !== \"INPUT\"))\n                        return;\n                    if (selection.toString().replace(/\\s+/g, \"\").length === 0)\n                        return;\n                    const element = this.createContextMenuOption(option, activeElement);\n                    this.contextMenuOptions.appendChild(element);\n                    return;\n                }\n                case \"Paste\":\n                case \"SelectAll\": {\n                    const selection = document.getSelection();\n                    const activeElement = document.activeElement;\n                    if (!activeElement ||\n                        !selection ||\n                        ![\"div\", \"input\", \"textarea\"].includes(activeElement.tagName.toLowerCase()))\n                        return;\n                    if (selection.rangeCount <= 0)\n                        return;\n                    const element = this.createContextMenuOption(option, activeElement);\n                    this.contextMenuOptions.appendChild(element);\n                    return;\n                }\n                case \"Refresh\":\n                    {\n                        /*\n                        We don't want to provide a reload page option when editing text, since it would\n                        make accidentally reloading annoying\n                      */\n                        const selection = document.getSelection();\n                        if ((selection === null || selection.toString().replace(/\\s+/g, \"\").length !== 0) &&\n                            document.activeElement === null)\n                            return;\n                        if (this.contextMenuOptions.children.length !== 0) {\n                            this.contextMenuOptions.appendChild(document.createElement(\"hr\"));\n                        }\n                    }\n                    break;\n            }\n            const element = this.createContextMenuOption(option);\n            this.contextMenuOptions.appendChild(element);\n        });\n    }\n    /** @description Creates the context menu options */\n    createContextMenuOption(optionType, activeElement) {\n        const baseElement = document.createElement(\"li\");\n        let optionText = optionType;\n        switch (optionType) {\n            case \"Copy\":\n                {\n                    baseElement.addEventListener(\"click\", () => {\n                        this.handleCopy();\n                    });\n                }\n                break;\n            case \"Cut\":\n                {\n                    baseElement.addEventListener(\"click\", () => {\n                        this.handleCopy(\"cut\", activeElement);\n                    });\n                }\n                break;\n            case \"Paste\":\n                {\n                    baseElement.addEventListener(\"click\", () => {\n                        const selection = document.getSelection();\n                        if (selection === null)\n                            return;\n                        if (\"clipboard\" in navigator) {\n                            // @ts-expect-error permissions\n                            navigator.permissions.query({ name: \"clipboard-read\" }).then((result) => {\n                                if (!(result.state === \"granted\" || result.state === \"prompt\"))\n                                    return;\n                                navigator.clipboard.read().then((value) => {\n                                    const firstType = value[0].types[0];\n                                    value[0].getType(firstType).then((blob_t) => {\n                                        const blob = blob_t;\n                                        const reader = new FileReader();\n                                        reader.onload = () => {\n                                            if (!reader.result || !activeElement)\n                                                return;\n                                            this.handleAfterPaste(reader.result, firstType, activeElement);\n                                            this.closeMenu();\n                                        };\n                                        reader.readAsText(blob);\n                                    });\n                                }, () => {\n                                    console.error(\"Failed reading the clipboard\");\n                                });\n                            });\n                        }\n                        else {\n                            console.error(\"Please upgrade your browser. The clipboard API is not enabled in your browser\");\n                        }\n                    });\n                }\n                break;\n            case \"SelectAll\":\n                {\n                    optionText = \"Select all\";\n                    baseElement.addEventListener(\"click\", () => {\n                        if (!activeElement)\n                            return;\n                        if ([\"input\", \"textarea\"].includes(activeElement.tagName.toLowerCase())) {\n                            const inputElement = activeElement;\n                            inputElement.focus(); // inputs\n                            inputElement.select();\n                        }\n                        else if (activeElement.tagName.toLowerCase() === \"div\") {\n                            const selection = document.getSelection();\n                            if (!selection)\n                                return;\n                            const range = document.createRange();\n                            range.selectNodeContents(this.editor);\n                            selection.removeAllRanges();\n                            selection.addRange(range);\n                        }\n                        this.closeMenu();\n                    });\n                }\n                break;\n            case \"Refresh\":\n                {\n                    optionText = \"Refresh page\";\n                    baseElement.addEventListener(\"click\", () => {\n                        window.location.reload();\n                    });\n                    // No need to close the menu, the page has refreshed\n                }\n                break;\n        }\n        const path = `./svg/op_${optionType.replace(/(?!^)([A-Z])/g, \"_$1\").toLowerCase()}.svg`;\n        const image = document.createElement(\"img\");\n        image.src = path;\n        baseElement.appendChild(image);\n        const span = document.createElement(\"span\");\n        span.innerText = optionText;\n        baseElement.appendChild(span);\n        return baseElement;\n    }\n    handleCopy(mode, activeElement) {\n        const selection = document.getSelection();\n        if (selection === null || selection.toString().replace(/\\s+/g, \"\").length === 0)\n            return;\n        const selectionText = selection.toString();\n        const partsFragment = selection.getRangeAt(0).cloneContents();\n        const fragmentChildNodes = partsFragment.childNodes;\n        const copiedElement = document.createElement(\"div\");\n        for (let i = 0; i < fragmentChildNodes.length; i++) {\n            const el = fragmentChildNodes.item(i);\n            if (el.nodeType === Node.ELEMENT_NODE) {\n                const element = el.cloneNode();\n                const def = document.createElement(\"div\");\n                const temp = document.createElement(\"div\");\n                def.style.fontFamily = \"Times\";\n                def.textContent = \"\";\n                temp.appendChild(element);\n                document.body.append(temp, def);\n                const defStyles = window.getComputedStyle(def);\n                const tempStyles = window.getComputedStyle(temp.children[0]);\n                let CSSString = \"\";\n                for (const property in tempStyles) {\n                    if (defStyles[property] === tempStyles[property])\n                        continue;\n                    const propertyName = property.replace(/([A-Z])/g, \"-$1\").toLowerCase();\n                    CSSString += `${propertyName}:${tempStyles[property]};`;\n                }\n                const spanElement = document.createElement(\"span\");\n                spanElement.setAttribute(\"style\", CSSString);\n                spanElement.innerHTML = el.innerHTML;\n                copiedElement.appendChild(spanElement);\n                [def, temp].forEach((e) => e.remove());\n            }\n            else if (el.nodeType === Node.TEXT_NODE) {\n                copiedElement.appendChild(el);\n            }\n        }\n        if (\"clipboard\" in navigator) {\n            // @ts-expect-error permissions\n            navigator.permissions.query({ name: \"clipboard-write\" }).then((result) => {\n                if (!(result.state === \"granted\" || result.state === \"prompt\"))\n                    return;\n                if (copiedElement.children.length === 0) {\n                    navigator.clipboard.writeText(selectionText).then(() => { }, // sucess (unused)\n                    () => {\n                        console.error(\"Failed copying text\");\n                    });\n                }\n                else {\n                    const htmlContent = copiedElement;\n                    const blob = new Blob([htmlContent.outerHTML], { type: \"text/html; charset=utf-8\" });\n                    const clipboardItem = new ClipboardItem({ \"text/html\": blob });\n                    navigator.clipboard.write([clipboardItem]).then(() => { }, // sucess (unused)\n                    () => {\n                        console.error(\"Failed copying content\");\n                    });\n                }\n            });\n        }\n        else {\n            /* NOTE: This is deprecrated an only used as fallback */\n            document.execCommand(\"copy\");\n        }\n        if (mode === \"cut\" && activeElement) {\n            if ([\"input\", \"textarea\"].includes(activeElement.tagName.toLowerCase())) {\n                const element = activeElement;\n                const start = element.selectionStart;\n                const end = element.selectionEnd;\n                console.log(start, end);\n                if (start === null || end === null)\n                    return;\n                const content = element.value;\n                element.value = `${content.substring(0, start)}${content.substring(end)}`;\n            }\n            else if (activeElement.tagName.toLowerCase() === \"div\") {\n                const selection = document.getSelection();\n                if (!selection) {\n                    this.closeMenu();\n                    return;\n                }\n                const range = selection.getRangeAt(0);\n                range.deleteContents();\n            }\n        }\n        this.closeMenu();\n    }\n    /** @description Handles after paste event */\n    handleAfterPaste(value, type, lastActiveElement) {\n        switch (type) {\n            case \"text/plain\":\n                {\n                    const pasted = value.trim();\n                    if ([\"input\", \"textarea\"].includes(lastActiveElement.tagName.toLowerCase())) {\n                        const input = lastActiveElement;\n                        if (!input.selectionStart || !input.selectionEnd)\n                            return;\n                        input.setRangeText(pasted, input.selectionStart, input.selectionEnd);\n                    }\n                    else if (lastActiveElement.tagName.toLowerCase() === \"div\") {\n                        const selection = window.getSelection();\n                        if (!selection)\n                            return;\n                        if (selection.rangeCount !== 0) {\n                            const range = selection.getRangeAt(0);\n                            const textContent = document.createTextNode(value);\n                            range.deleteContents();\n                            range.insertNode(textContent);\n                            range.setStart(textContent, textContent.length);\n                            range.collapse(true);\n                            selection.removeAllRanges();\n                            selection.addRange(range);\n                        }\n                    }\n                }\n                break;\n            case \"text/html\":\n                {\n                    const selection = window.getSelection();\n                    if (!selection)\n                        return;\n                    const range = selection.getRangeAt(0);\n                    const node = document.createElement(\"div\");\n                    node.innerHTML = value.trim();\n                    const element = node.firstChild;\n                    if (element.nodeName.toLowerCase() === \"img\") {\n                        const image = element;\n                        if (!image)\n                            return;\n                        image.onload = () => {\n                            if (!(image.naturalWidth > this.editor.getBoundingClientRect().width))\n                                return;\n                            image.width = this.editor.getBoundingClientRect().width;\n                        };\n                    }\n                    range.deleteContents();\n                    range.insertNode(element);\n                    range.setStartAfter(element);\n                    range.collapse(true);\n                    selection.removeAllRanges();\n                    selection.addRange(range);\n                }\n                break;\n        }\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n/**\n *\n * @description Handles document styles, such as bold, italics, superscript, fonts,\n * text justification, etc.\n *\n */\nexport default class DocumentStyles {\n    constructor() {\n        this.fontFamilyJoiner = document.querySelector(\"#text-format-font\");\n        this.fontFamilyInput = document.querySelector(\"#format-font-family\");\n        this.fontFamilyDropdown = document.querySelector(\"#font-family-dropdown\");\n        this.editor = document.querySelector(\"#editor\");\n        this.boldButton = document.querySelector(\"#format-bold\");\n        this.italicButton = document.querySelector(\"#format-italics\");\n        this.imageUploadButton = document.querySelector(\"#format-upload-button\");\n        this.justifyLeftButton = document.querySelector(\"#format-justify-left\");\n        this.justifyCenterButton = document.querySelector(\"#format-justify-center\");\n        this.justifyRightButton = document.querySelector(\"#format-justify-right\");\n        this.justifyEvenButton = document.querySelector(\"#format-justify-even\");\n        this.underlineButton = document.querySelector(\"#format-underline\");\n        this.strikeButtonButton = document.querySelector(\"#format-strike\");\n        this.supScriptButton = document.querySelector(\"#format-sup\");\n        this.subScriptButton = document.querySelector(\"#format-sub\");\n        this.instantiateDocumentStyles();\n    }\n    /** @description instantiates document styles */\n    instantiateDocumentStyles() {\n        this.instantiateTextStyles();\n        this.instantiateTextJustification();\n        this.instantiateDropdown();\n    }\n    /** @description Instantiate text styles (bold, italics, font...) */\n    instantiateTextStyles() {\n        /**\n         * FIXME: THIS IS DEPECRECATED AND COULD STOP WORKING AT ANY MOMENT\n         * */\n        this.boldButton.addEventListener(\"click\", () => document.execCommand(\"bold\", false));\n        this.italicButton.addEventListener(\"click\", () => document.execCommand(\"italic\", false));\n        this.underlineButton.addEventListener(\"click\", () => document.execCommand(\"underline\", false));\n        this.strikeButtonButton.addEventListener(\"click\", () => document.execCommand(\"strikeThrough\", false));\n        this.supScriptButton.addEventListener(\"click\", () => document.execCommand(\"superScript\", false));\n        this.subScriptButton.addEventListener(\"click\", () => document.execCommand(\"subScript\", false));\n        this.instantiateUploadImage();\n    }\n    /** @description Sets events for text justification by the click of a button */\n    instantiateTextJustification() {\n        this.justifyCenterButton.addEventListener(\"click\", this.justify(\"center\"));\n        this.justifyLeftButton.addEventListener(\"click\", this.justify(\"left\"));\n        this.justifyRightButton.addEventListener(\"click\", this.justify(\"right\"));\n        this.justifyEvenButton.addEventListener(\"click\", this.justify(\"justify\"));\n    }\n    /** @description Uploads an image to the document at cursor position */\n    instantiateUploadImage() {\n        this.imageUploadButton.onclick = () => {\n            this.handleImageUpload();\n        };\n    }\n    /** @description Handles the uploaded images */\n    handleImageUpload() {\n        const selection = document.getSelection();\n        if (!selection)\n            return;\n        const range = selection.getRangeAt(0);\n        const uploadInput = document.createElement(\"input\");\n        uploadInput.setAttribute(\"type\", \"file\");\n        uploadInput.setAttribute(\"accept\", \"image/*\");\n        uploadInput.setAttribute(\"multiple\", \"\");\n        uploadInput.addEventListener(\"change\", (e) => {\n            const fileList = e.target.files;\n            if (!fileList)\n                return;\n            const imageList = [];\n            this.readURLS(fileList).then((srcList) => {\n                for (const src of srcList) {\n                    const image = new Image();\n                    image.src = src;\n                    imageList.push(image);\n                }\n                if (range.commonAncestorContainer !== this.editor && !this.editor.contains(range.commonAncestorContainer))\n                    return;\n                range.deleteContents();\n                for (const image of imageList) {\n                    if (image.naturalWidth >= this.editor.getBoundingClientRect().width) {\n                        image.width = this.editor.getBoundingClientRect().width;\n                    }\n                    range.insertNode(image);\n                    range.setEndBefore(image);\n                }\n                uploadInput.remove();\n            });\n        });\n        uploadInput.style.display = \"none\";\n        document.body.appendChild(uploadInput);\n        uploadInput.click();\n    }\n    /** @description reads images src urls then returns them */\n    readURLS(fileList) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const srcList = [];\n            const promises = [];\n            /*\n              Why we are doing it this way is because reader.onload is asynchronous\n              without supporting .then() or any operation that would make the value\n              usable synchronously\n            */\n            for (const file of fileList) {\n                const reader = new FileReader();\n                const promise = new Promise((resolve, reject) => {\n                    reader.onload = () => {\n                        if (!reader.result)\n                            return;\n                        srcList.push(reader.result);\n                        resolve();\n                    };\n                    reader.onerror = reject;\n                    reader.readAsDataURL(file);\n                });\n                promises.push(promise);\n            }\n            yield Promise.all(promises);\n            return srcList;\n        });\n    }\n    /** @description Handles text justification events */\n    justify(position) {\n        return () => {\n            const selection = window.getSelection();\n            if (!selection)\n                return;\n            let parentNode = selection.focusNode;\n            /* recursively traverse parents to find the ones that are paragraph leveled */\n            if (parentNode && parentNode.parentElement !== this.editor) {\n                while (parentNode !== null && parentNode.parentElement !== this.editor) {\n                    parentNode = parentNode === null || parentNode === void 0 ? void 0 : parentNode.parentElement;\n                }\n            }\n            if (parentNode === null)\n                return;\n            const paragraphNode = parentNode;\n            if (selection.anchorNode === selection.focusNode) {\n                paragraphNode.setAttribute(\"data-text-align\", position);\n            }\n            else {\n                let endNode = selection.anchorNode;\n                if (endNode && endNode.parentElement !== this.editor) {\n                    while (endNode !== null && endNode.parentElement !== this.editor) {\n                        endNode = endNode === null || endNode === void 0 ? void 0 : endNode.parentElement;\n                    }\n                }\n                if (!endNode)\n                    return;\n                const childEndPosition = Array.from(this.editor.children).indexOf(endNode);\n                const childStartPosition = Array.from(this.editor.children).indexOf(paragraphNode);\n                const positionSet = {\n                    start: childStartPosition < childEndPosition ? childStartPosition : childEndPosition,\n                    end: (childStartPosition < childEndPosition ? childEndPosition : childStartPosition) + 1,\n                };\n                for (let i = positionSet.start; i < positionSet.end; i++) {\n                    if (!this.editor.children[i])\n                        break;\n                    this.editor.children[i].setAttribute(\"data-text-align\", position);\n                }\n            }\n        };\n    }\n    /**\n     * @description a function used to replace the document.execCommand() element creation, as\n     * behaviour varies between browsers, normalizing this function can lead to more consistent behaviour\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/execCommand | document.execCommand(); }\n     */\n    wrapElement(element) {\n        const selection = document.getSelection();\n        if (!selection)\n            return;\n        const range = selection.getRangeAt(0);\n        const children = range.extractContents();\n        if (children.childNodes.length === 0)\n            return;\n        console.log(element);\n        // TODO:\n    }\n    /** @description matches all subchildren of a certain type */\n    matchAllSubChildren(root) {\n        const result = [];\n        for (const node of this.traverseChildren(root)) {\n            if (node.nodeName === root.nodeName) {\n                result.push(node);\n            }\n        }\n        return result;\n    }\n    /** @description traverses children of a node */\n    *traverseChildren(element) {\n        if (!element)\n            return;\n        yield element;\n        for (const node of element.childNodes) {\n            yield* this.traverseChildren(node);\n        }\n    }\n    /** @description Show dropdown indicating the font list under the font select menu */\n    instantiateDropdown() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const boundBox = this.fontFamilyJoiner.getBoundingClientRect();\n            const dropdown = this.fontFamilyDropdown;\n            dropdown.style.width = `${boundBox.width}px`;\n            dropdown.style.height = `${boundBox.height}px`;\n            dropdown.style.left = `${boundBox.left}px`;\n            dropdown.style.top = `${boundBox.top + boundBox.height}px`;\n            this.fontFamilyInput.addEventListener(\"focus\", () => {\n                dropdown.style.display = \"block\";\n            });\n            this.fontFamilyInput.addEventListener(\"blur\", () => {\n                dropdown.style.display = \"none\";\n            });\n        });\n    }\n}\n","/**\n *\n * @description Configures events relative to the functions of the text editing\n * within the editor\n *\n **/\nexport default class EditorFunctions {\n    constructor() {\n        this.editor = document.querySelector(\"#editor\");\n        this.formatFontSizeInput = document.querySelector(\"#format-font-size\");\n        this.initialDiv = document.querySelector(\"#initial-content\");\n        this.configureEditorFunctions();\n    }\n    configureEditorFunctions() {\n        this.editor.addEventListener(\"blur\", () => this.handleEmptyEditor());\n        this.editor.addEventListener(\"paste\", (e) => this.handlePaste(e));\n        this.editor.addEventListener(\"beforeinput\", (e) => this.handleEditorInput(e));\n        this.formatFontSizeInput.addEventListener(\"keydown\", (e) => this.enforeDigitOnly(e));\n        this.formatFontSizeInput.addEventListener(\"click\", () => this.handleInputFocus(this.formatFontSizeInput));\n        this.editor.addEventListener(\"keydown\", (e) => this.restrictInitialDiv(e));\n    }\n    /** @description Clears the editor when empty (remaining <div>, <br> elements) */\n    handleEmptyEditor() {\n        if (this.editor.innerText.replace(/\\s+/g, \"\").length !== 0)\n            return;\n        if (!(this.editor.childNodes.length === 1 && this.editor.childNodes[0].nodeType === Node.TEXT_NODE))\n            return;\n        this.initialDiv.innerHTML = \"\";\n    }\n    handleEditorInput(e) {\n        switch (e.inputType) {\n            case \"insertParagraph\":\n                {\n                    this.handleParagraphInsertion(e);\n                }\n                break;\n        }\n    }\n    /** @description Overrides the default keydown event for a contenteditable <div> element */\n    handleParagraphInsertion(e) {\n        var _a;\n        const selection = window.getSelection();\n        const activeNode = (_a = selection.focusNode) === null || _a === void 0 ? void 0 : _a.parentElement;\n        if (activeNode === this.initialDiv) {\n            e.preventDefault();\n            const secondNode = document.createElement(\"div\");\n            secondNode.innerText = \"\\u200B\";\n            const align = this.initialDiv.getAttribute(\"data-text-align\");\n            const possibleAlignments = [\"left\", \"center\", \"right\", \"justify\"];\n            if (align && possibleAlignments.includes(align)) {\n                secondNode.setAttribute(\"data-text-align\", align);\n            }\n            this.initialDiv.after(secondNode);\n            setTimeout(() => {\n                const range = new Range();\n                range.setStart(secondNode, 0);\n                range.setEnd(secondNode, 0);\n                selection.removeAllRanges();\n                selection.addRange(range);\n            });\n        }\n    }\n    /** @description Handles the paste event */\n    handlePaste(e) {\n        if (!e.clipboardData)\n            return;\n        const data = e.clipboardData;\n        if (data.types.length === 0)\n            return;\n        const html = data.getData(\"text/html\");\n        const template = document.createElement(\"template\");\n        template.innerHTML = html;\n        if (!template.content)\n            return;\n        const fragment = template.content;\n        const elements = [];\n        for (const node of fragment.childNodes) {\n            if (node.nodeType === Node.TEXT_NODE || node.nodeType === Node.ELEMENT_NODE) {\n                elements.push(node);\n            }\n        }\n        const selection = document.getSelection();\n        if (!selection)\n            return;\n        const toBeAppendedFragment = document.createDocumentFragment();\n        toBeAppendedFragment.append(...elements);\n        const range = selection.getRangeAt(0);\n        range.deleteContents();\n        range.insertNode(toBeAppendedFragment);\n        // FIXME: This doesn't quite work + images\n        range.setStartAfter(toBeAppendedFragment);\n        range.collapse(true);\n        selection.removeAllRanges();\n        selection.addRange(range);\n    }\n    /** @description Prevents the initial div from being deleted */\n    restrictInitialDiv(e) {\n        if (e.key !== \"Backspace\")\n            return;\n        if (this.initialDiv.innerText.replace(/\\n|\\s/g, \"\") === \"\") {\n            const selection = window.getSelection();\n            if (!selection)\n                return;\n            let parentNode = selection.anchorNode;\n            /** recursively traverse elements until encountering the editor as a parent node */\n            if (!(parentNode && parentNode.parentElement !== this.editor))\n                return;\n            while (parentNode !== null && parentNode.parentElement !== this.editor) {\n                parentNode = parentNode === null || parentNode === void 0 ? void 0 : parentNode.parentElement;\n            }\n            if (parentNode !== this.initialDiv)\n                return;\n            e.preventDefault();\n        }\n    }\n    /** @description Selects entire input content onfocus */\n    handleInputFocus(inputElement) {\n        inputElement.focus();\n        inputElement.select();\n    }\n    /** @description Enforces digit only input or backspace for deletion */\n    enforeDigitOnly(e) {\n        if (!/Backspace|\\d/g.test(e.key))\n            e.preventDefault();\n    }\n}\n","/**\n *\n * @description Handles file imports / exports.\n *\n */\nexport default class ImportExport {\n    constructor() {\n        this.closeViewsBackground = document.querySelector(\"#close-import-export-view\");\n        this.editor = document.querySelector(\"#editor\");\n        this.exportButton = document.querySelector(\"#export-button\");\n        this.importButton = document.querySelector(\"#import-button\");\n        this.exportView = document.querySelector(\"#export-document-view\");\n        this.importView = document.querySelector(\"#import-document-view\");\n        this.importDragZone = document.querySelector(\"#import-drag-zone\");\n        this.instantiateImportExport();\n    }\n    instantiateImportExport() {\n        this.handleViews();\n        this.handleImports();\n    }\n    handleImports() {\n        this.importDragZone.addEventListener(\"click\", () => this.handleDocumentImport());\n    }\n    handleDocumentImport() {\n        const fileInput = document.createElement(\"input\");\n        fileInput.setAttribute(\"type\", \"file\");\n        fileInput.style.display = \"none\";\n        fileInput.addEventListener(\"change\", (e) => this.handleUpload(e));\n        document.body.appendChild(fileInput);\n        fileInput.click();\n    }\n    /** @description handles the uploaded files */\n    handleUpload(e) {\n        const target = e.target;\n        const files = target.files;\n        if (!files || files.length !== 1)\n            return;\n        const file = files[0];\n        const reader = new FileReader();\n        reader.onload = () => {\n            const content = reader.result;\n            if (!reader.result || content.length === 0)\n                return;\n            console.log(file.type);\n            this.importContent(content, file.type);\n        };\n        reader.readAsText(file);\n    }\n    /** @description imports the content from a file type to  */\n    importContent(content, type) {\n        if (this.editor.textContent) {\n            const textContent = this.editor.textContent;\n            if (textContent.replace(/\\s+/g, \"\").length !== 0) {\n                console.log(\"empty\");\n            }\n        }\n        switch (type) {\n            /* no extension is interpreted as an alias of \"text/plain\" */\n            case \"\":\n            case \"text/plain\":\n                {\n                    if (content.replace(/\\s+/g, \"\"))\n                        return; // TODO: Better indications for the document being empty\n                }\n                break;\n            default:\n                {\n                    const span = this.importDragZone.querySelector(\"span\");\n                    const oldContent = span.textContent;\n                    span.textContent = `File type, ${type} not supported`;\n                    setTimeout(() => {\n                        span.textContent = oldContent;\n                    }, 2000);\n                }\n                break;\n        }\n    }\n    handleViews() {\n        this.exportButton.addEventListener(\"click\", () => this.handleExport());\n        this.importButton.addEventListener(\"click\", () => this.handleImport());\n        this.closeViewsBackground.addEventListener(\"click\", () => this.closeViews());\n    }\n    /** @description exports the current document as a file */\n    handleExport() {\n        this.exportButton.addEventListener(\"click\", () => {\n            this.exportView.style.display = \"block\";\n            this.closeViewsBackground.style.display = \"block\";\n        });\n    }\n    /** @description imports content to the current document */\n    handleImport() {\n        this.importButton.addEventListener(\"click\", () => {\n            this.importView.style.display = \"block\";\n            this.closeViewsBackground.style.display = \"block\";\n        });\n    }\n    closeViews() {\n        this.closeViewsBackground.style.display = \"none\";\n        this.exportView.style.display = \"none\";\n        this.importView.style.display = \"none\";\n    }\n}\n","/**\n *\n * @description Instantiates User Interface events\n *\n */\nexport default class UserInterface {\n    constructor() {\n        this.editor = document.querySelector(\"#editor\");\n        this.titleInput = document.querySelector(\"#title-input\");\n        this.zoomRangeInput = document.querySelector(\"#zoom-range\");\n        this.zoomInput = document.querySelector(\"#zoom-control-input\");\n        /*\n          localStorage.getItem(\"zoomLevel\") is a non-nullish value since it has been instantiated\n          within the Storage class.\n        */\n        this.zoomCurr = parseInt(localStorage.getItem(\"zoomLevel\"), 10) / 100;\n        this.MAX_ALLOWED_ZOOM = parseFloat(this.zoomRangeInput.max);\n        this.MIN_ALLOWED_ZOOM = parseFloat(this.zoomRangeInput.min); // TODO:\n        this.MAX_TITLE_LENGTH = 50;\n        this.instantiateUIEvents();\n    }\n    /** @description instanciates a group of unrelated UIEvents */\n    instantiateUIEvents() {\n        document.title = \"Azu - Document 1\";\n        this.titleInput.addEventListener(\"change\", () => this.handleTitleInput());\n        this.titleInput.addEventListener(\"blur\", () => this.handleTitleBlur());\n        this.instantiateZoom();\n    }\n    /**\n     *\n     * @description Handles window zoom through document scaling\n     *\n     **/\n    /** @description instantiates the zoom function */\n    instantiateZoom() {\n        document.addEventListener(\"wheel\", (e) => this.handleWheelZoom(e), { passive: false });\n        document.addEventListener(\"keydown\", (e) => this.handleKeyZoom(e));\n        this.zoomRangeInput.addEventListener(\"input\", (e) => this.handleRangeZoom(e));\n        this.zoomInput.addEventListener(\"blur\", () => this.handleInputZoom());\n        this.zoomInput.addEventListener(\"click\", () => this.handleInputFocus(this.zoomInput));\n        this.zoomInput.addEventListener(\"keydown\", (e) => this.enforeDigitOnly(e));\n    }\n    /** @description Zooms only the inner document portion onwheel */\n    handleWheelZoom(e) {\n        if (!e.ctrlKey)\n            return;\n        e.preventDefault();\n        /* Different browsers usually have a different increment on zoom */\n        const addedZoom = (e.deltaY * -1 < 0 ? -1 : 1) * 0.25;\n        if (this.zoomCurr + addedZoom > this.MAX_ALLOWED_ZOOM || this.zoomCurr + addedZoom < this.MIN_ALLOWED_ZOOM)\n            return;\n        this.zoomCurr += addedZoom;\n        this.editor.style.scale = `${this.zoomCurr}`;\n        this.zoomRangeInput.value = `${this.zoomCurr}`;\n        this.zoomInput.value = `${Math.floor(parseFloat((this.zoomCurr * 100).toFixed(2)))}`;\n    }\n    /** @description Zooms only the inner document portion on `CTRL` + `+`, `CTRL` + `-` */\n    handleKeyZoom(e) {\n        if (!e.ctrlKey)\n            return;\n        const isZoomingIn = e.key === \"+\" || e.key === \"=\";\n        if ([\"+\", \"-\", \"=\", \"_\"].includes(e.key)) {\n            e.preventDefault();\n            const addedZoom = isZoomingIn ? 0.25 : -0.25;\n            if (this.zoomCurr + addedZoom <= 0 || this.zoomCurr + addedZoom > this.MAX_ALLOWED_ZOOM)\n                return;\n            this.zoomCurr += addedZoom;\n            this.editor.style.scale = `${this.zoomCurr}`;\n            this.zoomRangeInput.value = `${this.zoomCurr}`;\n            this.zoomInput.value = `${this.zoomCurr * 100}`;\n        }\n    }\n    /** @description Handles the zoom with a slider (range input) */\n    handleRangeZoom(e) {\n        const target = e.target;\n        const zoomValue = parseFloat(target.value);\n        this.zoomInput.value = `${zoomValue * 100}`;\n        this.editor.style.scale = `${zoomValue}`;\n    }\n    /** @description Handles the zoom through input */\n    handleInputZoom() {\n        let previousZoom = this.zoomCurr;\n        const zoomAmount = parseInt(this.zoomInput.value, 10) / 100;\n        this.zoomCurr = zoomAmount >= this.MAX_ALLOWED_ZOOM ? this.MAX_ALLOWED_ZOOM : zoomAmount;\n        if (this.zoomCurr < this.MIN_ALLOWED_ZOOM) {\n            if (previousZoom < this.MIN_ALLOWED_ZOOM)\n                previousZoom = 1;\n            this.zoomInput.value = `${previousZoom * 100}`;\n            this.editor.style.scale = `${previousZoom}`;\n            return;\n        }\n        this.zoomInput.value = `${this.zoomCurr * 100}`;\n        this.editor.style.scale = `${this.zoomCurr}`;\n    }\n    /** @description Selects entire input content onfocus */\n    handleInputFocus(inputElement) {\n        inputElement.focus();\n        inputElement.select();\n    }\n    /** @description Enforces digit only input */\n    enforeDigitOnly(e) {\n        if (!/Backspace|\\d/g.test(e.code))\n            e.preventDefault();\n    }\n    /** @description If the title value is invalid, set the document title to \"Unnamed\" */\n    handleTitleBlur() {\n        const content = this.titleInput.value;\n        if (content.replace(/\\s*/g, \"\") !== \"\")\n            return;\n        this.titleInput.value = \"Unnamed\";\n    }\n    /** @description On title change, set document.title */\n    handleTitleInput() {\n        const title = this.titleInput.value;\n        if (title.replace(/\\s*/g, \"\") === \"\") {\n            document.title = \"Azu - Unnamed\";\n        }\n        else {\n            const ellidedString = title.length >= this.MAX_TITLE_LENGTH ? `${title.substring(0, this.MAX_TITLE_LENGTH - 3)}...` : title;\n            document.title = `Azu - ${ellidedString}`;\n        }\n    }\n}\n","/**\n *\n * @description serves to extend other correctors\n *\n */\nexport default class Corrector {\n    constructor() {\n        this.lang = \"\";\n        this.numberRegex =\n            /(^(?![a-zA-Z]))(((-?\\d+(\\.\\d+)?((e)(\\+|-)\\d+)?i?)(?![a-zA-Z]))|0x([a-fA-F]|\\d)+|0b(0|1)+|0o[0-7]+)(?=\\b)/gi;\n    }\n    correct(text, index) {\n        return [{ term: text, index: index }];\n    }\n}\n","/**\n *\n * @description corrects French text\n *\n */\nimport Corrector from \"./corrector\";\nexport class FrenchCorrector extends Corrector {\n    constructor(dictionnary) {\n        super();\n        (this.lang = \"french\"), (this.dictionnary = dictionnary);\n    }\n    /** @description corrects mistakes */\n    correct(text, index) {\n        const content = this.cleanContent(text);\n        if (content.replace(/\\s+|\\u200B/g, \"\").length === 0)\n            return [];\n        return this.correctOrthography(content, index);\n    }\n    /** @description cleans the content */\n    cleanContent(text) {\n        const cleaned = text.replace(/\\u00A0/g, \" \").trim();\n        return cleaned;\n    }\n    /** @description checks the ortography of a sequence of words */\n    correctOrthography(content, index) {\n        const punctuationRegex = /!|\\.|\\(|\\)|\\[|\\]|\\$|;|:|&|\\*|@|\\{|\\}|\"|'|<|>|\\+|-/g;\n        const words = content.replace(punctuationRegex, \"\").split(\" \");\n        const errors = [];\n        for (const word of words) {\n            const numberRegex = this.numberRegex;\n            if (word.match(numberRegex))\n                continue;\n            if (word.includes(\"'\")) {\n                const apostrophes = word.match(/\"'\"/g);\n                if (apostrophes && apostrophes.length >= 2) {\n                    errors.push({ term: word, index: index });\n                }\n            }\n            else if (word.match(/([a-zA-Z]|||||||||||||)+/gi)) {\n                if (this.dictionnary.includes(word.toLocaleLowerCase()))\n                    continue;\n                errors.push({ term: word, index: index });\n            }\n            else {\n                if (word.replace(/\\s+/g, \"\").length === 0)\n                    continue;\n                errors.push({ term: word, index: index });\n            }\n        }\n        return errors;\n    }\n}\n","/**\n *\n * @description Configures settings\n *\n */\nexport default class Settings {\n    constructor() {\n        this.appView = document.querySelector(\"#app\");\n        this.closeSettingsButton = document.querySelector(\"#close-settings-button\");\n        this.openSettingsButton = document.querySelector(\"#setting-button\");\n        this.settingsView = document.querySelector(\"#settings-view\");\n        this.themeSelectContainer = document.querySelector(\"#theme-option-select-ul\");\n        this.initialise_settings();\n    }\n    initialise_settings() {\n        this.iniChangeView();\n    }\n    /** @description instantiates events relating to opening and closing the settings*/\n    iniChangeView() {\n        this.openSettingsButton.addEventListener(\"click\", () => this.setSettingView(\"open\"));\n        this.closeSettingsButton.addEventListener(\"click\", () => this.setSettingView(\"close\"));\n        this.instantiateThemeSelect();\n    }\n    /** @description opens or closes the settings view */\n    setSettingView(state) {\n        this.appView.style.display = state === \"open\" ? \"none\" : \"block\";\n        this.settingsView.style.display = state === \"open\" ? \"block\" : \"none\";\n    }\n    /** @description Changes the current theme of the document based on the user option */\n    instantiateThemeSelect() {\n        for (let i = 0; i < this.themeSelectContainer.childElementCount; i++) {\n            const children = this.themeSelectContainer.children.item(i);\n            if ([\"light-theme-option\", \"dark-theme-option\", \"system-theme-option\"].includes(children.id)) {\n                children.addEventListener(\"click\", () => {\n                    const activeThemeLabel = \"active-theme\";\n                    if (document.querySelector(`.${activeThemeLabel}`) !== null) {\n                        const element = this.themeSelectContainer.querySelector(`.${activeThemeLabel}`);\n                        element.classList.remove(activeThemeLabel);\n                    }\n                    children.classList.add(activeThemeLabel);\n                    document.body.setAttribute(\"class\", children.id.replace(\"-theme-option\", \"\"));\n                });\n            }\n        }\n    }\n}\n","/**\n *\n * @description initialises events relative to word count, word length, mistakes,\n * or about the document itself\n *\n **/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nexport default class Statictics {\n    constructor() {\n        this.editor = document.querySelector(\"#editor\");\n        this.statisticsContainer = document.querySelector(\"#statistics-container\");\n        this.statisticsCover = document.querySelector(\"#close-statistics\");\n        this.statisticsView = document.querySelector(\"#statitics-view\");\n        this.wordCountContainer = document.querySelector(\"#word-count\");\n        this.COUNT_INTERVAL = 5000;\n        this.initializeStatistics();\n    }\n    initializeStatistics() {\n        this.wordCountContainer.addEventListener(\"click\", () => this.openStatisticsView());\n        this.statisticsCover.addEventListener(\"click\", () => this.closeStatisticsView());\n        this.configureWordCount();\n    }\n    /** @description Count words at an interval */\n    configureWordCount() {\n        let timer = setTimeout(() => { });\n        this.editor.addEventListener(\"input\", () => {\n            clearTimeout(timer);\n            timer = setTimeout(() => {\n                queueMicrotask(() => {\n                    const textContent = this.editor.innerText;\n                    const textLength = textContent\n                        .trim()\n                        .split(/\\s+/g)\n                        .filter((x) => x !== \"\").length;\n                    this.wordCountContainer.innerText = `${textLength === 0 ? \"No\" : textLength} word${textLength === 1 ? \"\" : \"s\"}`;\n                });\n            }, this.COUNT_INTERVAL);\n        });\n    }\n    /** @description Opens a window related to statistics of the document */\n    openStatisticsView() {\n        this.statisticsView.style.display = \"block\";\n        this.statisticsCover.style.display = \"block\";\n        const content = this.editor.textContent;\n        if (!content) {\n            return;\n        }\n        const text = content\n            .replace(/\\s+/g, \" \")\n            .trim()\n            .replace(/\\.|,|:|;|\\(|\\)|\\[|\\]/g, \"\");\n        this.countWords(text).then((words) => {\n            this.computeStatistics(words);\n        });\n    }\n    /** @description Counts words asynchronously since some texts can be large */\n    countWords(text) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const words = text.split(\" \");\n            return words;\n        });\n    }\n    /** @description computes statistics */\n    computeStatistics(words) {\n        const wordCount = words.length;\n        const averageWordLength = words.length === 0 ? 0 : words.join(\"\").length / words.length;\n        const longestTerm = words.reduce((a, b) => (a.length > b.length ? a : b));\n        const distribution = [];\n        const lengthArray = words.map((x) => x.length);\n        for (let i = 1; i < longestTerm.length + 1; i++) {\n            const filteredList = lengthArray.filter((x) => x === i);\n            distribution.push({ [i]: filteredList.length });\n        }\n        const distributionImage = this.drawDistribution(distribution.filter((x) => Object.values(x)[0] !== 0), wordCount, { width: 1000, height: 500 });\n        const statsObj = {\n            wordCount: wordCount,\n            wordAverageLength: parseFloat(averageWordLength.toFixed(2)),\n            wordLengthDistributionImage: distributionImage,\n        };\n        this.displayStatistics(statsObj);\n    }\n    closeStatisticsView() {\n        this.statisticsView.style.display = \"none\";\n        this.statisticsCover.style.display = \"none\";\n    }\n    /** @description draws the distribution on a canvas element used for plotting */\n    drawDistribution(distribution, distributionLength, dimensions) {\n        if (distribution.length === 0)\n            return null;\n        const graph = document.createElement(\"canvas\");\n        const context = graph.getContext(\"2d\");\n        graph.width = dimensions.width;\n        graph.height = dimensions.height;\n        const lineWidth = graph.width * 0.9;\n        const lineHeight = graph.height / 25;\n        const lineX = (graph.width - lineWidth) / 2;\n        const lineY = graph.height * 0.85 - lineHeight / 2;\n        context.fillStyle = \"#ccc\";\n        context.strokeStyle = context.fillStyle;\n        context.fillRect(lineX, lineY, lineWidth, lineHeight);\n        context.strokeRect(lineX, lineY, lineWidth, lineHeight);\n        const barWidth = (lineWidth / distribution.length) * 0.8;\n        const gap = barWidth - barWidth * 0.8;\n        for (let i = 0; i < distribution.length; i++) {\n            const item = distribution[i];\n            const wordLength = parseInt(Object.keys(item)[0]);\n            const barHeight = (Object.values(item)[0] / distributionLength) * (graph.height * 0.65);\n            const barX = barWidth * i + gap * i + lineX;\n            const barY = lineY - barHeight;\n            const fontsize = barWidth / 3 > 64 ? 64 : barWidth / 3;\n            context.font = `${fontsize}px sans-serif`;\n            context.fillStyle = \"#000000\";\n            context.fillText(wordLength.toString(), barX + barWidth / 2 - barWidth / 3 / 2, barY - 10);\n            context.fillStyle = \"#75E19A\";\n            context.fillRect(barX, barY, barWidth, barHeight);\n        }\n        return new URL(graph.toDataURL());\n    }\n    /** @description displays the statistics in a readable manner */\n    displayStatistics(statisticsObject) {\n        this.statisticsContainer.innerHTML = \"\";\n        const statsFrag = document.createDocumentFragment();\n        const statsList = document.createElement(\"ul\");\n        for (const entry of Object.entries(statisticsObject)) {\n            switch (entry[0]) {\n                case \"wordCount\":\n                    {\n                        const wordCount = entry[1];\n                        const li = document.createElement(\"li\");\n                        li.innerText = `Number of words : ${wordCount}`;\n                        statsList.appendChild(li);\n                        console.log(wordCount);\n                    }\n                    break;\n                case \"wordAverageLength\":\n                    {\n                        const averageWordLength = entry[1];\n                        const li = document.createElement(\"li\");\n                        li.innerText = `Average word length : ${averageWordLength}`;\n                        statsList.appendChild(li);\n                        console.log(averageWordLength);\n                    }\n                    break;\n                case \"wordLengthDistributionImage\":\n                    {\n                        if (entry[1] === null)\n                            return;\n                        const imageURL = entry[1];\n                        const li = document.createElement(\"li\");\n                        const span = document.createElement(\"span\");\n                        span.innerText = \"Word length distribution :\";\n                        li.appendChild(span);\n                        const image = new Image(200);\n                        image.src = imageURL.href;\n                        li.appendChild(document.createElement(\"br\"));\n                        li.appendChild(image);\n                        statsList.appendChild(li);\n                    }\n                    break;\n            }\n        }\n        statsFrag.appendChild(statsList);\n        this.statisticsContainer.append(statsFrag);\n    }\n}\n","/**\n *\n * @description Manages the storage, stores some values such as previous session zoom\n *\n **/\nexport default class Storage {\n    constructor() {\n        this.editor = document.querySelector(\"#editor\");\n        this.themeSelectContainer = document.querySelector(\"#theme-option-select-ul\");\n        this.zoomRangeInput = document.querySelector(\"#zoom-range\");\n        this.zoomInput = document.querySelector(\"#zoom-control-input\");\n        this.zoomAmount = 1;\n        this.instantiateStorage();\n    }\n    /** @description Instatiates all storage methods */\n    instantiateStorage() {\n        this.instantiateLocalStorage();\n    }\n    /** @description Instantiates localStorage */\n    instantiateLocalStorage() {\n        window.addEventListener(\"beforeunload\", () => {\n            const currentSettings = {\n                theme: document.body.getAttribute(\"class\"),\n                lang: document.body.getAttribute(\"lang\"),\n            };\n            localStorage.setItem(\"zoomLevel\", this.zoomInput.value);\n            localStorage.setItem(\"Settings\", JSON.stringify(currentSettings));\n        });\n        document.addEventListener(\"DOMContentLoaded\", () => {\n            const zoomLevel = localStorage.getItem(\"zoomLevel\");\n            if (zoomLevel !== null && !Number.isNaN(parseInt(zoomLevel, 10))) {\n                this.zoomAmount = parseInt(zoomLevel, 10);\n                this.zoomRangeInput.value = `${this.zoomAmount / 100}`;\n                this.zoomInput.value = `${this.zoomAmount}`;\n                this.editor.style.scale = `${this.zoomAmount / 100}`;\n            }\n            else {\n                this.editor.style.scale = \"1\";\n            }\n            const fetchedSettings = localStorage.getItem(\"Settings\");\n            if (fetchedSettings === null)\n                return;\n            const settings = JSON.parse(fetchedSettings);\n            for (const [key, value] of Object.entries(settings)) {\n                switch (key) {\n                    case \"theme\":\n                        {\n                            if (value === null)\n                                return;\n                            document.body.setAttribute(\"class\", `${value}`);\n                            const themeSelectLi = this.themeSelectContainer.querySelector(`#${value}-theme-option`);\n                            if (document.querySelector(\".active-theme\") === null) {\n                                themeSelectLi.classList.add(\"active-theme\");\n                            }\n                            else {\n                                const activeElement = document.querySelector(\".active-theme\");\n                                if (!activeElement)\n                                    return;\n                                activeElement.classList.remove(\"active-theme\");\n                                themeSelectLi.classList.add(\"active-theme\");\n                            }\n                        }\n                        break;\n                    case \"lang\":\n                        {\n                            if (value === null)\n                                return;\n                            document.body.setAttribute(\"lang\", `${value}`);\n                        }\n                        break;\n                }\n            }\n        });\n    }\n}\n","/**\n *\n * @description Implements text correction\n *\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { FrenchCorrector } from \"./languages/french\";\nexport default class TextCorrection {\n    constructor() {\n        this.contextMenu = document.querySelector(\"#context-menu\");\n        this.contextMenuOptions = document.querySelector(\"#context-menu-options\");\n        this.contextMenuOverlay = document.querySelector(\"#main-cover\");\n        this.editor = document.querySelector(\"#editor\");\n        /* Internal states */\n        this.currentLanguage = \"\";\n        this.currentCorrector = null;\n        this.wordSet = [];\n        this.TEXT_CORRECTION_INTERVAL = 1000;\n        this.iniTextCorrection();\n    }\n    iniTextCorrection() {\n        let timer = setTimeout(() => { });\n        this.editor.addEventListener(\"input\", () => {\n            clearTimeout(timer);\n            timer = setTimeout(() => {\n                const language = \"french\";\n                this.scanText(language);\n            }, this.TEXT_CORRECTION_INTERVAL);\n        });\n    }\n    /** @description loads a specified dictionnary, containing words in the specified language */\n    loadDictionnary(language) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield fetch(`./json/${language}.json`);\n            const dictionnary = (yield response.json());\n            this.currentLanguage = language;\n            this.wordSet = dictionnary;\n        });\n    }\n    /** @description scan text to find words */\n    scanText(language) {\n        if (this.wordSet.length === 0 || this.currentLanguage !== language) {\n            this.loadDictionnary(language).then(() => {\n                this.identifyParagraphs(language);\n            });\n        }\n        else {\n            this.identifyParagraphs(language);\n        }\n    }\n    /** @description identify the paragraphs to correct */\n    identifyParagraphs(lang) {\n        let i = 0;\n        for (const el of this.editor.children) {\n            const paragraph = el;\n            if (paragraph.textContent === \"\" || paragraph.textContent === null) {\n                i += 1;\n                continue;\n            }\n            this.correctText({ content: paragraph.textContent, paragraphIndex: i }, lang);\n            i += 1;\n        }\n    }\n    /** @description corrects text based on current language */\n    correctText(contentValue, language) {\n        let tokens = [];\n        if (this.currentCorrector === null || this.currentCorrector.lang !== language) {\n            switch (this.currentLanguage) {\n                case \"french\":\n                    {\n                        this.currentCorrector = new FrenchCorrector(this.wordSet);\n                    }\n                    break;\n            }\n        }\n        tokens = this.currentCorrector.correct(contentValue.content, contentValue.paragraphIndex);\n        if (tokens.length === 0)\n            return;\n        this.markIncorrect(tokens);\n    }\n    /** @description marks text inccorrect in the editor */\n    markIncorrect(tokens) {\n        /*\n          FIXME: Part of a detected erred word can appear as an error\n          within any word that contains a substring matching that word\n          for example: have and ve, ve is erred, but the \"ve\" part of\n          \"have\" is highlighted (when \"ve\" is written last ?)\n        */\n        const rangeSet = [];\n        for (const token of tokens) {\n            const node = this.editor.children[token.index];\n            const textNodes = this.filterTextNodesUnder(node);\n            const unifiedText = textNodes.map((x) => x.textContent).join(\"\\uFFFF\");\n            if (token.term.replace(/\\s+/g, \"\").length === 0)\n                continue;\n            const termRegex = new RegExp(`\\\\b${token.term.split(\"\").join(\"\\uFFFF?\")}\\\\b`, \"g\");\n            const match = unifiedText.match(termRegex);\n            if (!match || match.length === 0)\n                continue;\n            const delimitations = [];\n            let separators = this.getIndicesOf(\"\\uFFFF\", unifiedText);\n            if (!separators || separators.length === 0)\n                separators = [];\n            if (match.length === 1) {\n                let temp = \"\";\n                const startIndex = unifiedText.indexOf(match[0]);\n                for (let i = startIndex; i < unifiedText.length; i++) {\n                    temp += unifiedText[i];\n                    if (temp.match(termRegex))\n                        break;\n                }\n                const endIndex = startIndex + temp.length;\n                delimitations.push({ start: startIndex, end: endIndex });\n            }\n            else {\n                for (const m of match) {\n                    const indices = this.getIndicesOf(m, unifiedText);\n                    if (!indices)\n                        continue;\n                    for (const index of indices) {\n                        let temp = \"\";\n                        for (let i = index; i < unifiedText.length; i++) {\n                            temp += unifiedText[i];\n                            if (temp.match(termRegex))\n                                break;\n                        }\n                        const endIndex = index + temp.length;\n                        delimitations.push({ start: index, end: endIndex });\n                    }\n                }\n            }\n            /* Remove duplicated objects (identical keys and values) */\n            const delimitationsSet = [...new Set(delimitations.map((item) => JSON.stringify(item)))].map((item) => JSON.parse(item));\n            for (const delimitation of delimitationsSet) {\n                const ps = separators.filter((x) => x <= delimitation.start); // separators passed (start)\n                const pn = separators.filter((x) => x < delimitation.end); // separators passed (end)\n                const startingNodeIndex = ps.length;\n                const endingNodeIndex = pn.length;\n                let startOffset, endOffset = 0;\n                if (ps.length !== 0) {\n                    startOffset = delimitation.start - ps[ps.length - 1] - 1;\n                }\n                else {\n                    startOffset = delimitation.start;\n                }\n                if (pn.length !== 0) {\n                    endOffset = delimitation.end - pn[pn.length - 1] - 1;\n                }\n                else {\n                    endOffset = delimitation.end;\n                }\n                const range = new Range();\n                range.setStart(textNodes[startingNodeIndex], startOffset);\n                range.setEnd(textNodes[endingNodeIndex], endOffset);\n                rangeSet.push(range);\n            }\n        }\n        this.createErrorElements(rangeSet);\n    }\n    /** @description creates the error elements from the provided ranges */\n    createErrorElements(rangeArray) {\n        /* FIXME: Maintain user cursor position within a erred span */\n        for (const range of rangeArray) {\n            const contents = range.extractContents().childNodes;\n            if (contents.length === 0)\n                continue;\n            const spanElement = this.createErrorSpan();\n            for (let i = 0; i < contents.length; i++) {\n                const child = contents.item(i);\n                if (child.nodeType === Node.ELEMENT_NODE) {\n                    const element = child;\n                    if (element.textContent === \"\")\n                        element.remove();\n                }\n            }\n            spanElement.append(...contents);\n            range.insertNode(spanElement);\n        }\n        this.cleanUpDeeplyNested();\n    }\n    /**\n     * @description removes nth time nested terms and adds a MutationObserver\n     * to see changes, after replacing nested elements\n     */\n    cleanUpDeeplyNested() {\n        const errorElements = document.getElementsByClassName(\"error\");\n        if (errorElements.length === 0)\n            return;\n        for (const error of errorElements) {\n            if (error.querySelector(\".error\")) {\n                const nodes = this.selectAllMatching(\".error\", error);\n                const span = this.createErrorSpan();\n                span.append(...nodes[nodes.length - 1].childNodes);\n                error.replaceWith(span);\n            }\n        }\n        for (let i = 0; i < document.getElementsByClassName(\"error\").length; i++) {\n            const child = document.getElementsByClassName(\"error\").item(i);\n            this.observeSpan(child);\n        }\n    }\n    /** @description generator method used to traverse children */\n    *traverseChildren(element) {\n        if (!element)\n            return;\n        yield element;\n        for (const node of element.childNodes) {\n            yield* this.traverseChildren(node);\n        }\n    }\n    /** @description get nodes matching a selector */\n    selectAllMatching(selector, root) {\n        const result = [];\n        for (const node of this.traverseChildren(root)) {\n            if (node.nodeType === Node.ELEMENT_NODE) {\n                if (node.matches(selector)) {\n                    result.push(node);\n                }\n            }\n        }\n        return result;\n    }\n    /** @description creates the error span elements */\n    createErrorSpan() {\n        const span = document.createElement(\"span\");\n        span.addEventListener(\"contextmenu\", () => this.displaySuggestions(span));\n        span.setAttribute(\"class\", \"error\");\n        return span;\n    }\n    /** @description observes if the user corrects their mistakes, removes span if so */\n    observeSpan(span) {\n        const configuration = {\n            characterData: true,\n            childList: true,\n            subtree: true,\n        };\n        const callback = (mutationList, observer) => {\n            for (const mutation of mutationList) {\n                if (!mutation.target)\n                    observer.disconnect();\n                const text = span.textContent;\n                if (!text || text === \"\")\n                    return;\n                const checkCorrected = this.currentCorrector.correct(text.toLowerCase(), -1);\n                if (checkCorrected.length === 0) {\n                    const textNode = new Text(text);\n                    const selection = document.getSelection();\n                    const oldRange = selection.getRangeAt(0);\n                    const startOffset = oldRange.startOffset;\n                    const endOffset = oldRange.endOffset;\n                    span.replaceWith(textNode);\n                    console.log(startOffset, endOffset);\n                    setTimeout(() => {\n                        const newRange = new Range();\n                        newRange.setStart(textNode, startOffset);\n                        newRange.setEnd(textNode, endOffset);\n                        newRange.collapse(false);\n                        selection.removeAllRanges();\n                        selection.addRange(newRange);\n                    });\n                }\n            }\n        };\n        const observer = new MutationObserver(callback);\n        observer.observe(span, configuration);\n    }\n    /** @description computes suggestions for the current term*/\n    displaySuggestions(span) {\n        const text = span.textContent;\n        if (!text)\n            return;\n        this.contextMenu.style.display = \"none\";\n        this.computeSuggestions(text).then((suggestions) => {\n            setTimeout(() => {\n                this.editContextMenu(suggestions.map((x) => x.term), text, span);\n            });\n        });\n    }\n    /** @description edits the contextMenu in order to add the suggestions */\n    editContextMenu(suggestions, originalTerm, errorElement) {\n        const errorMessage = document.createElement(\"li\");\n        const suggestionFragment = document.createDocumentFragment();\n        errorMessage.setAttribute(\"id\", \"correction-error-option\");\n        const languageDescriptor = document.createElement(\"h1\");\n        const capitalizedLang = this.currentLanguage[0].toLocaleUpperCase() + this.currentLanguage.slice(1);\n        languageDescriptor.textContent = capitalizedLang;\n        suggestionFragment.appendChild(languageDescriptor);\n        const suggestionMessage = document.createElement(\"p\");\n        if (suggestions.length === 0) {\n            suggestionMessage.innerHTML = `No suggestions for the term ${originalTerm}`;\n            suggestionFragment.appendChild(suggestionMessage);\n        }\n        else {\n            const errMessage = `The spelling for the term\n      ${originalTerm} seems incorrect, here are some suggestions :`;\n            suggestionMessage.innerHTML = errMessage;\n            const suggestionUL = document.createElement(\"ul\");\n            suggestions.forEach((suggestion) => {\n                const suggestionLi = document.createElement(\"li\");\n                suggestionLi.textContent = suggestion;\n                suggestionLi.addEventListener(\"click\", () => {\n                    const textNode = new Text(suggestion);\n                    errorElement.replaceWith(textNode);\n                    this.contextMenu.style.display = \"none\";\n                    this.contextMenuOverlay.style.display = \"none\";\n                });\n                suggestionUL.appendChild(suggestionLi);\n            });\n            suggestionFragment.appendChild(suggestionMessage);\n            suggestionFragment.appendChild(suggestionUL);\n        }\n        errorMessage.appendChild(suggestionFragment);\n        const contextMenuFirstChild = this.contextMenuOptions.firstElementChild;\n        const errorJoiner = document.createDocumentFragment();\n        errorJoiner.append(errorMessage, document.createElement(\"hr\"));\n        this.contextMenuOptions.insertBefore(errorJoiner, contextMenuFirstChild);\n        this.contextMenu.style.display = \"block\";\n        this.contextMenuOverlay.style.display = \"block\";\n    }\n    /** @description compares the passed term to one in the dictionary */\n    computeSuggestions(term) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const word = term.toLowerCase();\n            let filteredList = [];\n            if (term.length <= 5) {\n                filteredList = this.wordSet.filter((x) => x.startsWith(word[0]));\n            }\n            else {\n                filteredList = this.wordSet.filter((x) => x.startsWith(word.slice(0, 2)));\n            }\n            return yield this.computeSimilarity(term, filteredList);\n        });\n    }\n    /**\n     * @description computes the similarity between a word set and a word\n     */\n    computeSimilarity(term, list) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const suggestions = [];\n            for (let i = 0; i < list.length; i++) {\n                const distance = this.computeLevenstheinDistance(term, list[i]);\n                suggestions.push({ term: list[i], dif: distance });\n            }\n            return suggestions\n                .sort((a, b) => a.dif - b.dif)\n                .reverse()\n                .slice(0, 3);\n        });\n    }\n    /**\n     * @description computes the similarity between two strings using the Levensthein distance\n     * @see https://rosettacode.org/wiki/Levenshtein_distance#TypeScript\n     */\n    computeLevenstheinDistance(first, second) {\n        const m = first.length, n = second.length;\n        let t = [...Array(n + 1).keys()], u = [];\n        for (let i = 0; i < m; i++) {\n            u = [i + 1];\n            for (let j = 0; j < n; j++) {\n                u[j + 1] = first[i] === second[j] ? t[j] : Math.min(t[j], t[j + 1], u[j]) + 1;\n            }\n            t = u;\n        }\n        return 1 - u[n] / Math.max(m, n);\n    }\n    /**\n     * @description Gets the indices of where a string n appears.\n     * @see https://stackoverflow.com/questions/3410464\n     */\n    getIndicesOf(targetString, objectString) {\n        if (targetString.length === 0)\n            return [];\n        let startIndex, index = 0;\n        const indices = [];\n        while ((index = objectString.indexOf(targetString, startIndex)) > -1) {\n            indices.push(index);\n            startIndex = index + targetString.length;\n        }\n        return indices;\n    }\n    /**\n     * @description filters text nodes under an element\n     * @see https://stackoverflow.com/questions/10730309\n     */\n    filterTextNodesUnder(element) {\n        const children = [];\n        const walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT);\n        while (walker.nextNode() !== null) {\n            children.push(walker.currentNode);\n        }\n        return children;\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n/**\n *\n * @description configurates automatic / manual translations\n *\n */\nexport default class Translations {\n    constructor() {\n        this.editor = document.querySelector(\"#editor\");\n        this.formatBoldButton = document.querySelector(\"#format-bold\");\n        this.formatItalicButton = document.querySelector(\"#format-italics\");\n        this.formatUnderlineButton = document.querySelector(\"#format-underline\");\n        this.formatStrikeButton = document.querySelector(\"#format-strike\");\n        this.settingsAccessibilityTitle = document.querySelector(\"[data-tr-acc]\");\n        this.settingsAppearanceTitle = document.querySelector(\"[data-tr-appearance]\");\n        this.settingsDescription = document.querySelector(\"[data-tr-description]\");\n        this.settingsInterfaceLanguage = document.querySelector(\"[data-tr-intl]\");\n        this.settingsThemesTitle = document.querySelector(\"[data-tr-themes]\");\n        this.settingsThemesDark = document.querySelector(\"[data-tr-th-dark]\");\n        this.settingsThemesLight = document.querySelector(\"[data-tr-th-light]\");\n        this.settingsThemesSystem = document.querySelector(\"[data-tr-th-sys]\");\n        this.settingsThemesCustom = document.querySelector(\"[data-tr-th-cus]\");\n        this.settingsTitle = document.querySelector(\"[data-tr-settings]\");\n        this.titleInput = document.querySelector(\"#title-input\");\n        this.initialContentDiv = document.querySelector(\"#initial-content\");\n        this.languageSelection = document.querySelector(\"#language-options\");\n        this.documentNames = new Set();\n        this.translations = {};\n        this.instantiateTranslations();\n    }\n    /** @description instantiates events for translations */\n    instantiateTranslations() {\n        (() => __awaiter(this, void 0, void 0, function* () {\n            yield this.fetchTranslations().then((json) => {\n                this.translations = json;\n                Object.values(json).forEach((translation) => {\n                    const t = translation;\n                    this.documentNames.add(t.document_initial_title);\n                });\n            });\n            /** this.translations and this.documentNames might not exist yet FIXME: */\n            // this.instantiateLanguageSelection();\n        }))();\n    }\n    /** @description fetches the .json file containing all translations */\n    fetchTranslations() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield fetch(\"./json/translations.json\");\n            const translations = yield response.json().catch((e) => {\n                console.error(e);\n            });\n            return translations;\n        });\n    }\n    /** @description sets the interface language, to the specified value */\n    setInterfaceLanguage(language) {\n        if (Object.keys(this.translations).length === 0 || this.translations[language] === undefined)\n            return;\n        const translationobj = this.translations[language];\n        this.titleInput.placeholder = translationobj.document_no_title_placeholder;\n        if (this.documentNames.has(this.titleInput.value)) {\n            this.titleInput.value = translationobj.document_initial_title;\n            document.title = `Azu - ${translationobj.document_initial_title}`;\n        }\n        /* FIXME: This is very ugly but it works \\_()_/ */\n        this.initialContentDiv.setAttribute(\"data-placeholder\", translationobj.document_place_holder);\n        this.formatBoldButton.children[0].innerHTML = translationobj.format_text_button.bold;\n        this.formatItalicButton.children[0].innerHTML = translationobj.format_text_button.italic;\n        this.formatUnderlineButton.children[0].innerHTML = translationobj.format_text_button.underline;\n        this.formatStrikeButton.children[0].innerHTML = translationobj.format_text_button.strike;\n        this.settingsTitle.textContent = translationobj.settings.title;\n        this.settingsDescription.textContent = translationobj.settings.description;\n        this.settingsAccessibilityTitle.textContent = translationobj.settings.accessibility.title;\n        this.settingsInterfaceLanguage.textContent = translationobj.settings.accessibility.interface_language.title;\n        this.settingsAppearanceTitle.textContent = translationobj.settings.appearance.title;\n        this.settingsThemesTitle.textContent = translationobj.settings.appearance.theme_title;\n        this.settingsThemesLight.textContent = translationobj.settings.appearance.themes.light;\n        this.settingsThemesDark.textContent = translationobj.settings.appearance.themes.dark;\n        this.settingsThemesSystem.querySelector(\"span\").childNodes[0] =\n            translationobj.settings.appearance.themes.system;\n        this.settingsThemesCustom.textContent = translationobj.settings.appearance.themes.custom;\n    }\n    /** @description Allows for the user to change their language */\n    instantiateLanguageSelection() {\n        this.languageSelection.addEventListener(\"change\", () => {\n            const selectedLang = this.languageSelection.children[this.languageSelection.selectedIndex].getAttribute(\"lang\");\n            if (selectedLang === null)\n                return;\n            this.editor.setAttribute(\"lang\", \"zh-hans\");\n            switch (selectedLang) {\n                case \"ja\":\n                    {\n                        this.editor.setAttribute(\"lang\", \"ja\");\n                    }\n                    break;\n                case \"zh-hant\":\n                    {\n                        this.editor.setAttribute(\"lang\", \"zh-hant\");\n                    }\n                    break;\n            }\n            document.body.setAttribute(\"lang\", selectedLang);\n            this.setInterfaceLanguage(selectedLang);\n        });\n    }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport Editor from \"./modules/editor\";\nclass Main {\n    constructor() {\n        this.ini();\n    }\n    /** @description Initializes the App */\n    ini() {\n        this.instantiateServiceWorker();\n        new Editor();\n    }\n    /** @description instantiates a Service worker */\n    instantiateServiceWorker() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!(\"serviceWorker\" in navigator)) {\n                console.error(\"[Service worker] : Service worker not available, please upgrade your browser.\");\n                return;\n            }\n            yield navigator.serviceWorker.register(\"./sw.js\", {\n                scope: \"./src/\",\n            });\n        });\n    }\n}\nnew Main();\n"],"names":[],"sourceRoot":""}