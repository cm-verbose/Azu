{"version":3,"file":"script.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;AAA2D;AACf;AACF;AACM;AACE;AACO;AACA;AACL;AACD;AACnD;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA,YAAY,0DAAO;AACnB,YAAY,4DAAa;AACzB;AACA;AACA;AACA;AACA,YAAY,+DAAW;AACvB,YAAY,kEAAc;AAC1B,YAAY,mEAAe;AAC3B,YAAY,2DAAQ;AACpB,YAAY,6DAAU;AACtB,YAAY,kEAAc;AAC1B,YAAY,+DAAY;AACxB;AACA;;;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,4BAA4B;AAC9D,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,EAAE;AAC3C,wCAAwC,EAAE;AAC1C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,wBAAwB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,iCAAiC;AACjC;AACA,iCAAiC;AACjC,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,iCAAiC,yDAAyD;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+BAA+B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,aAAa,GAAG,sBAAsB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,yBAAyB;AACnE;AACA;AACA;AACA,+EAA+E;AAC/E;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qEAAqE,kBAAkB,gBAAgB;AACvG,8DAA8D,mBAAmB;AACjF,6EAA6E;AAC7E;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,4BAA4B,EAAE,uBAAuB;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACrWA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,qBAAqB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,eAAe;AACrD,uCAAuC,gBAAgB;AACvD,qCAAqC,cAAc;AACnD,oCAAoC,+BAA+B;AACnE;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;;;;;;;;;;;;;;;AC1JA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC3HA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,gBAAgB;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,cAAc;AACnD,uCAAuC,cAAc;AACrD,kCAAkC,yDAAyD;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,cAAc;AACvD,2CAA2C,cAAc;AACzD,sCAAsC,oBAAoB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gBAAgB;AAClD,qCAAqC,UAAU;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,mBAAmB;AACzD,yCAAyC,aAAa;AACtD;AACA;AACA,kCAAkC,oBAAoB;AACtD,qCAAqC,cAAc;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,8CAA8C;AAC3H,sCAAsC,cAAc;AACpD;AACA;AACA;;;;;;;;;;;;;;;AC3HA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,sCAAsC,MAAM,4BAA4B;AACnI,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4BAA4B;AACpD;AACA,gCAAgC,0BAA0B;AAC1D;AACA,4HAA4H,0BAA0B;AACtJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,SAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,UAAU;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,kBAAkB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC5KA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,+CAA+C,sBAAsB;AACrE,0CAA0C,gBAAgB;AAC1D,6CAA6C,sBAAsB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,MAAM;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,MAAM;AACxE;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;AC3DA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,mDAAmD,KAAK;AACxD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gCAAgC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,KAAK;AAC/E;AACA;AACA;AACA,0DAA0D,KAAK;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACrQA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,sCAAsC;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;UCjHA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;ACNA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uDAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA","sources":["webpack://azu/./src/ts/modules/editor.ts","webpack://azu/./src/ts/modules/functions/context_menu.ts","webpack://azu/./src/ts/modules/functions/document_styles.ts","webpack://azu/./src/ts/modules/functions/editor_functions.ts","webpack://azu/./src/ts/modules/functions/interface.ts","webpack://azu/./src/ts/modules/functions/settings.ts","webpack://azu/./src/ts/modules/functions/statistics.ts","webpack://azu/./src/ts/modules/functions/storage.ts","webpack://azu/./src/ts/modules/functions/text_correction.ts","webpack://azu/./src/ts/modules/functions/translations.ts","webpack://azu/webpack/bootstrap","webpack://azu/webpack/runtime/define property getters","webpack://azu/webpack/runtime/hasOwnProperty shorthand","webpack://azu/webpack/runtime/make namespace object","webpack://azu/./src/ts/script.ts"],"sourcesContent":["import EditorFunctions from \"./functions/editor_functions\";\nimport Settings from \"./functions/settings\";\nimport Storage from \"./functions/storage\";\nimport Statictics from \"./functions/statistics\";\nimport UserInterface from \"./functions/interface\";\nimport TextCorrection from \"./functions/text_correction\";\nimport DocumentStyles from \"./functions/document_styles\";\nimport Translations from \"./functions/translations\";\nimport ContextMenu from \"./functions/context_menu\";\n/**\n *\n * @description Reprensents the editor itself, instantiates functions under sub-classes\n *\n */\nexport default class Editor {\n    constructor() {\n        this.ini();\n    }\n    /** @description initializes the editor */\n    ini() {\n        new Storage();\n        new UserInterface();\n        this.setEvents();\n    }\n    /** @description Configures editor functions */\n    setEvents() {\n        new ContextMenu();\n        new DocumentStyles();\n        new EditorFunctions();\n        new Settings();\n        new Statictics();\n        new TextCorrection();\n        new Translations();\n    }\n}\n","/**\n *\n * @description Handles the custom context menu's logic\n *\n */\nexport default class ContextMenu {\n    constructor() {\n        this.contextMenu = document.querySelector(\"#context-menu\");\n        this.contextMenuOptions = document.querySelector(\"#context-menu-options\");\n        this.ctxCover = document.querySelector(\"#main-cover\");\n        this.editor = document.querySelector(\"#editor\");\n        this.instantiateContextMenu();\n    }\n    /** @description instantiates methods to manipulate the context menu */\n    instantiateContextMenu() {\n        document.addEventListener(\"contextmenu\", (e) => {\n            e.preventDefault();\n            this.populateOptions();\n            this.ctxCover.style.display = \"block\";\n            this.contextMenu.style.display = \"block\";\n            this.handleOpenMenu({ x: e.clientX, y: e.clientY });\n        });\n        this.handleCloseMenu();\n    }\n    /** @description handles opening and positionning the menu, and adding events relative to opening the menu */\n    handleOpenMenu(atMousePos) {\n        const escMenuClose = (e) => {\n            if (e.key !== \"Escape\")\n                return;\n            e.preventDefault();\n            this.closeMenu();\n            document.removeEventListener(\"keydown\", escMenuClose);\n        };\n        document.addEventListener(\"keydown\", escMenuClose);\n        this.moveMenu(atMousePos.x, atMousePos.y);\n    }\n    /** @description move the menu to a specific position */\n    moveMenu(x, y) {\n        const boundingBox = this.contextMenu.getBoundingClientRect();\n        if (x + boundingBox.width > window.innerWidth) {\n            x = window.innerWidth - boundingBox.width;\n        }\n        if (y + boundingBox.height > window.innerHeight) {\n            y = window.innerHeight - boundingBox.height;\n        }\n        this.contextMenu.style.left = `${x}px`;\n        this.contextMenu.style.top = `${y}px`;\n    }\n    /** Closes the menu on exit of the cover */\n    handleCloseMenu() {\n        this.ctxCover.addEventListener(\"click\", () => {\n            this.closeMenu();\n        });\n    }\n    closeMenu() {\n        this.ctxCover.style.display = \"none\";\n        this.contextMenu.style.display = \"none\";\n    }\n    /** @description Appends created options to the context menu */\n    populateOptions() {\n        this.contextMenuOptions.innerHTML = \"\";\n        const options = [\"Copy\", \"Cut\", \"Paste\", \"SelectAll\", \"Refresh\"];\n        options.forEach((option) => {\n            switch (option) {\n                case \"Copy\":\n                    {\n                        const selection = document.getSelection();\n                        if (selection === null || selection.toString().replace(/\\s+/g, \"\").length === 0)\n                            return;\n                    }\n                    break;\n                case \"Cut\": {\n                    const selection = document.getSelection();\n                    const activeElement = document.activeElement;\n                    if (!activeElement || selection === null)\n                        return;\n                    if (selection.toString().replace(/\\s+/g, \"\").length === 0)\n                        return;\n                    const element = this.createContextMenuOption(option, activeElement);\n                    this.contextMenuOptions.appendChild(element);\n                    return;\n                }\n                case \"Paste\":\n                case \"SelectAll\": {\n                    const selection = document.getSelection();\n                    const activeElement = document.activeElement;\n                    if (!activeElement ||\n                        !selection ||\n                        ![\"div\", \"input\", \"textarea\"].includes(activeElement.tagName.toLowerCase()))\n                        return;\n                    if (selection.rangeCount <= 0)\n                        return;\n                    const element = this.createContextMenuOption(option, activeElement);\n                    this.contextMenuOptions.appendChild(element);\n                    return;\n                }\n                case \"Refresh\":\n                    {\n                        /*\n                        We don't want to provide a reload page option when editing text, since it would\n                        make accidentally reloading annoying\n                      */\n                        const selection = document.getSelection();\n                        if ((selection === null || selection.toString().replace(/\\s+/g, \"\").length !== 0) &&\n                            document.activeElement === null)\n                            return;\n                        if (this.contextMenuOptions.children.length !== 0) {\n                            this.contextMenuOptions.appendChild(document.createElement(\"hr\"));\n                        }\n                    }\n                    break;\n            }\n            const element = this.createContextMenuOption(option);\n            this.contextMenuOptions.appendChild(element);\n        });\n    }\n    /** @description Creates the context menu options */\n    createContextMenuOption(optionType, activeElement) {\n        const baseElement = document.createElement(\"li\");\n        let optionText = optionType;\n        switch (optionType) {\n            case \"Copy\":\n                {\n                    baseElement.addEventListener(\"click\", () => {\n                        this.handleCopy();\n                    });\n                }\n                break;\n            case \"Cut\":\n                {\n                    baseElement.addEventListener(\"click\", () => {\n                        this.handleCopy(\"cut\", activeElement);\n                    });\n                }\n                break;\n            case \"Paste\":\n                {\n                    baseElement.addEventListener(\"click\", () => {\n                        const selection = document.getSelection();\n                        if (selection === null)\n                            return;\n                        if (\"clipboard\" in navigator) {\n                            // @ts-expect-error permissions\n                            navigator.permissions.query({ name: \"clipboard-read\" }).then((result) => {\n                                if (!(result.state === \"granted\" || result.state === \"prompt\"))\n                                    return;\n                                navigator.clipboard.read().then((value) => {\n                                    const firstType = value[0].types[0];\n                                    value[0].getType(firstType).then((blob_t) => {\n                                        const blob = blob_t;\n                                        const reader = new FileReader();\n                                        reader.onload = () => {\n                                            if (!reader.result || !activeElement)\n                                                return;\n                                            this.handleAfterPaste(reader.result, firstType, activeElement);\n                                            this.closeMenu();\n                                        };\n                                        reader.readAsText(blob);\n                                    });\n                                }, () => {\n                                    console.error(\"Failed reading the clipboard\");\n                                });\n                            });\n                        }\n                        else {\n                            console.error(\"Please upgrade your browser. The clipboard API is not enabled in your browser\");\n                        }\n                    });\n                }\n                break;\n            case \"SelectAll\":\n                {\n                    optionText = \"Select all\";\n                    baseElement.addEventListener(\"click\", () => {\n                        if (!activeElement)\n                            return;\n                        if ([\"input\", \"textarea\"].includes(activeElement.tagName.toLowerCase())) {\n                            const inputElement = activeElement;\n                            inputElement.focus(); // inputs\n                            inputElement.select();\n                        }\n                        else if (activeElement.tagName.toLowerCase() === \"div\") {\n                            const selection = document.getSelection();\n                            if (!selection)\n                                return;\n                            const range = document.createRange();\n                            range.selectNodeContents(this.editor);\n                            selection.removeAllRanges();\n                            selection.addRange(range);\n                        }\n                        this.closeMenu();\n                    });\n                }\n                break;\n            case \"Refresh\":\n                {\n                    optionText = \"Refresh page\";\n                    baseElement.addEventListener(\"click\", () => {\n                        window.location.reload();\n                    });\n                    // No need to close the menu, the page has refreshed\n                }\n                break;\n        }\n        const path = `./svg/op_${optionType.replace(/(?!^)([A-Z])/g, \"_$1\").toLowerCase()}.svg`;\n        const image = document.createElement(\"img\");\n        image.src = path;\n        baseElement.appendChild(image);\n        const span = document.createElement(\"span\");\n        span.innerText = optionText;\n        baseElement.appendChild(span);\n        return baseElement;\n    }\n    handleCopy(mode, activeElement) {\n        const selection = document.getSelection();\n        if (selection === null || selection.toString().replace(/\\s+/g, \"\").length === 0)\n            return;\n        const selectionText = selection.toString();\n        const partsFragment = selection.getRangeAt(0).cloneContents();\n        const fragmentChildNodes = partsFragment.childNodes;\n        const copiedElement = document.createElement(\"div\");\n        for (let i = 0; i < fragmentChildNodes.length; i++) {\n            const el = fragmentChildNodes.item(i);\n            if (el.nodeType === Node.ELEMENT_NODE) {\n                const element = el.cloneNode();\n                const def = document.createElement(\"div\");\n                const temp = document.createElement(\"div\");\n                def.style.fontFamily = \"Times\";\n                def.textContent = \"\";\n                temp.appendChild(element);\n                document.body.append(temp, def);\n                const defStyles = window.getComputedStyle(def);\n                const tempStyles = window.getComputedStyle(temp.children[0]);\n                let CSSString = \"\";\n                for (const property in tempStyles) {\n                    if (defStyles[property] === tempStyles[property])\n                        continue;\n                    const propertyName = property.replace(/([A-Z])/g, \"-$1\").toLowerCase();\n                    CSSString += `${propertyName}:${tempStyles[property]};`;\n                }\n                const spanElement = document.createElement(\"span\");\n                spanElement.setAttribute(\"style\", CSSString);\n                spanElement.innerHTML = el.innerHTML;\n                copiedElement.appendChild(spanElement);\n                [def, temp].forEach((e) => e.remove());\n            }\n            else if (el.nodeType === Node.TEXT_NODE) {\n                copiedElement.appendChild(el);\n            }\n        }\n        if (\"clipboard\" in navigator) {\n            // @ts-expect-error permissions\n            navigator.permissions.query({ name: \"clipboard-write\" }).then((result) => {\n                if (!(result.state === \"granted\" || result.state === \"prompt\"))\n                    return;\n                if (copiedElement.children.length === 0) {\n                    navigator.clipboard.writeText(selectionText).then(() => { }, // sucess (unused)\n                    () => {\n                        console.error(\"Failed copying text\");\n                    });\n                }\n                else {\n                    const htmlContent = copiedElement;\n                    const blob = new Blob([htmlContent.outerHTML], { type: \"text/html; charset=utf-8\" });\n                    const clipboardItem = new ClipboardItem({ \"text/html\": blob });\n                    navigator.clipboard.write([clipboardItem]).then(() => { }, // sucess (unused)\n                    () => {\n                        console.error(\"Failed copying content\");\n                    });\n                }\n            });\n        }\n        else {\n            /* NOTE: This is deprecrated an only used as fallback */\n            document.execCommand(\"copy\");\n        }\n        if (mode === \"cut\" && activeElement) {\n            if ([\"input\", \"textarea\"].includes(activeElement.tagName.toLowerCase())) {\n                const element = activeElement;\n                const start = element.selectionStart;\n                const end = element.selectionEnd;\n                console.log(start, end);\n                if (start === null || end === null)\n                    return;\n                const content = element.value;\n                element.value = `${content.substring(0, start)}${content.substring(end)}`;\n            }\n            else if (activeElement.tagName.toLowerCase() === \"div\") {\n                const selection = document.getSelection();\n                if (!selection) {\n                    this.closeMenu();\n                    return;\n                }\n                const range = selection.getRangeAt(0);\n                range.deleteContents();\n            }\n        }\n        this.closeMenu();\n    }\n    /** @description Handles after paste event */\n    handleAfterPaste(value, type, lastActiveElement) {\n        switch (type) {\n            case \"text/plain\":\n                {\n                    const pasted = value.trim();\n                    if ([\"input\", \"textarea\"].includes(lastActiveElement.tagName.toLowerCase())) {\n                        const input = lastActiveElement;\n                        if (!input.selectionStart || !input.selectionEnd)\n                            return;\n                        input.setRangeText(pasted, input.selectionStart, input.selectionEnd);\n                    }\n                    else if (lastActiveElement.tagName.toLowerCase() === \"div\") {\n                        const selection = window.getSelection();\n                        if (!selection)\n                            return;\n                        if (selection.rangeCount !== 0) {\n                            const range = selection.getRangeAt(0);\n                            const textContent = document.createTextNode(value);\n                            range.deleteContents();\n                            range.insertNode(textContent);\n                            range.setStart(textContent, textContent.length);\n                            range.collapse(true);\n                            selection.removeAllRanges();\n                            selection.addRange(range);\n                        }\n                    }\n                }\n                break;\n            case \"text/html\":\n                {\n                    const selection = window.getSelection();\n                    if (!selection)\n                        return;\n                    const range = selection.getRangeAt(0);\n                    const node = document.createElement(\"div\");\n                    node.innerHTML = value.trim();\n                    const element = node.firstChild;\n                    if (element.nodeName.toLowerCase() === \"img\") {\n                        const image = element;\n                        if (!image)\n                            return;\n                        image.onload = () => {\n                            if (!(image.naturalWidth > this.editor.getBoundingClientRect().width))\n                                return;\n                            image.width = this.editor.getBoundingClientRect().width;\n                        };\n                    }\n                    range.deleteContents();\n                    range.insertNode(element);\n                    range.setStartAfter(element);\n                    range.collapse(true);\n                    selection.removeAllRanges();\n                    selection.addRange(range);\n                }\n                break;\n        }\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n/**\n *\n * @description Handles document styles, such as bold, italics, superscript, fonts,\n * text justification, etc.\n *\n */\nexport default class DocumentStyles {\n    constructor() {\n        this.fontFamilyJoiner = document.querySelector(\"#text-format-font\");\n        this.fontFamilyInput = document.querySelector(\"#format-font-family\");\n        this.fontFamilyDropdown = document.querySelector(\"#font-family-dropdown\");\n        this.editor = document.querySelector(\"#editor\");\n        this.boldButton = document.querySelector(\"#format-bold\");\n        this.italicButton = document.querySelector(\"#format-italics\");\n        this.justifyLeftButton = document.querySelector(\"#format-justify-left\");\n        this.justifyCenterButton = document.querySelector(\"#format-justify-center\");\n        this.justifyRightButton = document.querySelector(\"#format-justify-right\");\n        this.justifyEvenButton = document.querySelector(\"#format-justify-even\");\n        this.underlineButton = document.querySelector(\"#format-underline\");\n        this.strikeButtonButton = document.querySelector(\"#format-strike\");\n        this.supScriptButton = document.querySelector(\"#format-sup\");\n        this.subScriptButton = document.querySelector(\"#format-sub\");\n        this.instantiateDocumentStyles();\n    }\n    /** @description instantiates document styles */\n    instantiateDocumentStyles() {\n        this.instantiateTextStyles();\n        this.instantiateTextJustification();\n        this.instantiateDropdown();\n    }\n    /** @description Instantiate text styles (bold, italics, font...) */\n    instantiateTextStyles() {\n        /**\n         * FIXME: THIS IS DEPECRECATED AND COULD STOP WORKING AT ANY MOMENT\n         * TODO: THIS IS FEATURE DIFFERS FROM BROWSERS TO BROWSERS\n         * */\n        this.boldButton.addEventListener(\"click\", () => {\n            this.wrapElement(document.createElement(\"strong\"));\n        });\n        this.italicButton.addEventListener(\"click\", () => document.execCommand(\"italic\", false));\n        this.underlineButton.addEventListener(\"click\", () => document.execCommand(\"underline\", false));\n        this.strikeButtonButton.addEventListener(\"click\", () => document.execCommand(\"strikeThrough\", false));\n        this.supScriptButton.addEventListener(\"click\", () => document.execCommand(\"superScript\", false));\n        this.subScriptButton.addEventListener(\"click\", () => document.execCommand(\"subScript\", false));\n    }\n    /** @description Sets events for text justification by the click of a button */\n    instantiateTextJustification() {\n        this.justifyCenterButton.addEventListener(\"click\", this.justify(\"center\"));\n        this.justifyLeftButton.addEventListener(\"click\", this.justify(\"left\"));\n        this.justifyRightButton.addEventListener(\"click\", this.justify(\"right\"));\n        this.justifyEvenButton.addEventListener(\"click\", this.justify(\"justify\"));\n    }\n    /** @description Handles text justification events */\n    justify(position) {\n        return () => {\n            const selection = window.getSelection();\n            if (!selection)\n                return;\n            let parentNode = selection.focusNode;\n            /* recursively traverse parents to find the ones that are paragraph leveled */\n            if (parentNode && parentNode.parentElement !== this.editor) {\n                while (parentNode !== null && parentNode.parentElement !== this.editor) {\n                    parentNode = parentNode === null || parentNode === void 0 ? void 0 : parentNode.parentElement;\n                }\n            }\n            if (parentNode === null)\n                return;\n            const paragraphNode = parentNode;\n            if (selection.anchorNode === selection.focusNode) {\n                paragraphNode.setAttribute(\"data-text-align\", position);\n            }\n            else {\n                let endNode = selection.anchorNode;\n                if (endNode && endNode.parentElement !== this.editor) {\n                    while (endNode !== null && endNode.parentElement !== this.editor) {\n                        endNode = endNode === null || endNode === void 0 ? void 0 : endNode.parentElement;\n                    }\n                }\n                if (!endNode)\n                    return;\n                const childEndPosition = Array.from(this.editor.children).indexOf(endNode);\n                const childStartPosition = Array.from(this.editor.children).indexOf(paragraphNode);\n                const positionSet = {\n                    start: childStartPosition < childEndPosition ? childStartPosition : childEndPosition,\n                    end: (childStartPosition < childEndPosition ? childEndPosition : childStartPosition) + 1,\n                };\n                for (let i = positionSet.start; i < positionSet.end; i++) {\n                    if (!this.editor.children[i])\n                        break;\n                    this.editor.children[i].setAttribute(\"data-text-align\", position);\n                }\n            }\n        };\n    }\n    /**\n     * @description a function used to replace the document.execCommand() element creation\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/execCommand | document.execCommand(); }\n     */\n    wrapElement(element) {\n        // TODO: FIXME: \n        const selection = document.getSelection();\n        if (!selection)\n            return;\n        const range = selection.getRangeAt(0);\n        const childNodes = range.cloneContents().childNodes;\n        const elements = [];\n        for (const child of childNodes) {\n            elements.push(child);\n        }\n        range.deleteContents();\n        if (elements.length === 0)\n            return;\n        if (elements.length === 1) {\n            console.log(element, elements);\n            if (elements[0].parentElement && element.nodeType === elements[0].parentElement.nodeType) {\n                console.log(elements[0].childNodes);\n            }\n            else {\n                element.appendChild(elements[0]);\n                range.insertNode(element);\n                range.collapse(true);\n                range.setStartAfter(element);\n                selection.removeAllRanges();\n                selection.addRange(range);\n            }\n        }\n        console.log(elements, element);\n    }\n    /** @description Show dropdown indicating the font list under the font select menu */\n    instantiateDropdown() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const boundBox = this.fontFamilyJoiner.getBoundingClientRect();\n            const dropdown = this.fontFamilyDropdown;\n            dropdown.style.width = `${boundBox.width}px`;\n            dropdown.style.height = `${boundBox.height}px`;\n            dropdown.style.left = `${boundBox.left}px`;\n            dropdown.style.top = `${boundBox.top + boundBox.height}px`;\n            this.fontFamilyInput.addEventListener(\"focus\", () => {\n                dropdown.style.display = \"block\";\n            });\n            this.fontFamilyInput.addEventListener(\"blur\", () => {\n                dropdown.style.display = \"none\";\n            });\n        });\n    }\n}\n","/**\n *\n * @description Configures events relative to the functions of the text editing\n * within the editor\n *\n **/\nexport default class EditorFunctions {\n    constructor() {\n        this.editor = document.querySelector(\"#editor\");\n        this.formatFontSizeInput = document.querySelector(\"#format-font-size\");\n        this.initialDiv = document.querySelector(\"#initial-content\");\n        this.configureEditorFunctions();\n    }\n    configureEditorFunctions() {\n        this.editor.addEventListener(\"blur\", () => this.handleEmptyEditor());\n        this.editor.addEventListener(\"paste\", (e) => this.handlePaste(e));\n        this.editor.addEventListener(\"beforeinput\", (e) => this.handleEditorInput(e));\n        this.formatFontSizeInput.addEventListener(\"keydown\", (e) => this.enforeDigitOnly(e));\n        this.formatFontSizeInput.addEventListener(\"click\", () => this.handleInputFocus(this.formatFontSizeInput));\n        this.editor.addEventListener(\"keydown\", (e) => this.restrictInitialDiv(e));\n    }\n    /** @description Clears the editor when empty (remaining <div>, <br> elements) */\n    handleEmptyEditor() {\n        if (this.editor.innerText.replace(/\\s+/g, \"\").length !== 0)\n            return;\n        this.initialDiv.innerHTML = \"\";\n    }\n    handleEditorInput(e) {\n        switch (e.inputType) {\n            case \"insertParagraph\":\n                {\n                    this.handleParagraphInsertion(e);\n                }\n                break;\n        }\n    }\n    /** @description Overrides the default keydown event for a contenteditable <div> element */\n    handleParagraphInsertion(e) {\n        var _a;\n        const selection = window.getSelection();\n        const activeNode = (_a = selection.focusNode) === null || _a === void 0 ? void 0 : _a.parentElement;\n        if (activeNode === this.initialDiv) {\n            e.preventDefault();\n            const secondNode = document.createElement(\"div\");\n            secondNode.innerText = \"\\u200B\";\n            const align = this.initialDiv.getAttribute(\"data-text-align\");\n            const possibleAlignments = [\"left\", \"center\", \"right\", \"justify\"];\n            if (align && possibleAlignments.includes(align)) {\n                secondNode.setAttribute(\"data-text-align\", align);\n            }\n            this.initialDiv.after(secondNode);\n            setTimeout(() => {\n                const range = new Range();\n                range.setStart(secondNode, 0);\n                range.setEnd(secondNode, 0);\n                selection.removeAllRanges();\n                selection.addRange(range);\n            });\n        }\n    }\n    /** @description Handles the paste event */\n    handlePaste(e) {\n        if (!e.clipboardData)\n            return;\n        const data = e.clipboardData;\n        if (data.types.length === 0)\n            return;\n        const html = data.getData(\"text/html\");\n        const template = document.createElement(\"template\");\n        template.innerHTML = html;\n        if (!template.content)\n            return;\n        const fragment = template.content;\n        const elements = [];\n        for (const node of fragment.childNodes) {\n            if (node.nodeType === Node.TEXT_NODE || node.nodeType === Node.ELEMENT_NODE) {\n                elements.push(node);\n            }\n        }\n        const selection = document.getSelection();\n        if (!selection)\n            return;\n        const toBeAppendedFragment = document.createDocumentFragment();\n        toBeAppendedFragment.append(...elements);\n        const range = selection.getRangeAt(0);\n        range.deleteContents();\n        range.insertNode(toBeAppendedFragment);\n        // FIXME: This doesn't quite work + images\n        range.setStartAfter(toBeAppendedFragment);\n        range.collapse(true);\n        selection.removeAllRanges();\n        selection.addRange(range);\n    }\n    /** @description Prevents the initial div from being deleted */\n    restrictInitialDiv(e) {\n        if (e.key !== \"Backspace\")\n            return;\n        if (this.initialDiv.innerText.replace(/\\n|\\s/g, \"\") === \"\") {\n            const selection = window.getSelection();\n            if (!selection)\n                return;\n            let parentNode = selection.anchorNode;\n            /** recursively traverse elements until encountering the editor as a parent node */\n            if (!(parentNode && parentNode.parentElement !== this.editor))\n                return;\n            while (parentNode !== null && parentNode.parentElement !== this.editor) {\n                parentNode = parentNode === null || parentNode === void 0 ? void 0 : parentNode.parentElement;\n            }\n            if (parentNode !== this.initialDiv)\n                return;\n            e.preventDefault();\n        }\n    }\n    /** @description Selects entire input content onfocus */\n    handleInputFocus(inputElement) {\n        inputElement.focus();\n        inputElement.select();\n    }\n    /** @description Enforces digit only input or backspace for deletion */\n    enforeDigitOnly(e) {\n        if (!/Backspace|\\d/g.test(e.key))\n            e.preventDefault();\n    }\n}\n","/**\n *\n * @description Instantiates User Interface events\n *\n */\nexport default class UserInterface {\n    constructor() {\n        this.editor = document.querySelector(\"#editor\");\n        this.titleInput = document.querySelector(\"#title-input\");\n        this.zoomRangeInput = document.querySelector(\"#zoom-range\");\n        this.zoomInput = document.querySelector(\"#zoom-control-input\");\n        /*\n          localStorage.getItem(\"zoomLevel\") is a non-nullish value since it has been instantiated\n          within the Storage class.\n        */\n        this.zoomCurr = parseInt(localStorage.getItem(\"zoomLevel\"), 10) / 100;\n        this.MAX_ALLOWED_ZOOM = parseInt(this.zoomRangeInput.max);\n        this.MAX_TITLE_LENGTH = 50;\n        this.instantiateUIEvents();\n    }\n    /** @description instanciates a group of unrelated UIEvents */\n    instantiateUIEvents() {\n        document.title = \"Azu - Document 1\";\n        this.titleInput.addEventListener(\"change\", () => this.handleTitleInput());\n        this.titleInput.addEventListener(\"blur\", () => this.handleTitleBlur());\n        this.instantiateZoom();\n    }\n    /**\n     *\n     * @description Handles window zoom through document scaling\n     *\n     **/\n    /** @description instantiates the zoom function */\n    instantiateZoom() {\n        document.addEventListener(\"wheel\", (e) => this.handleWheelZoom(e), { passive: false });\n        document.addEventListener(\"keydown\", (e) => this.handleKeyZoom(e));\n        this.zoomRangeInput.addEventListener(\"input\", (e) => this.handleRangeZoom(e));\n        this.zoomInput.addEventListener(\"blur\", () => this.handleInputZoom());\n        this.zoomInput.addEventListener(\"click\", () => this.handleInputFocus(this.zoomInput));\n        this.zoomInput.addEventListener(\"keydown\", (e) => this.enforeDigitOnly(e));\n    }\n    /** @description Zooms only the inner document portion onwheel */\n    handleWheelZoom(e) {\n        if (!e.ctrlKey)\n            return;\n        e.preventDefault();\n        /* Different browsers usually have a different increment on zoom */\n        const addedZoom = (e.deltaY * -1 < 0 ? -1 : 1) * 0.25;\n        if (this.zoomCurr + addedZoom > this.MAX_ALLOWED_ZOOM ||\n            this.zoomCurr + addedZoom < parseFloat(this.zoomRangeInput.min))\n            return;\n        this.zoomCurr += addedZoom;\n        this.editor.style.scale = `${this.zoomCurr}`;\n        this.zoomRangeInput.value = `${this.zoomCurr}`;\n        this.zoomInput.value = `${Math.floor(parseFloat((this.zoomCurr * 100).toFixed(2)))}`;\n    }\n    /** @description Zooms only the inner document portion on `CTRL` + `+`, `CTRL` + `-` */\n    handleKeyZoom(e) {\n        if (!e.ctrlKey)\n            return;\n        const isZoomingIn = e.key === \"+\" || e.key === \"=\";\n        if ([\"+\", \"-\", \"=\", \"_\"].includes(e.key)) {\n            e.preventDefault();\n            const addedZoom = isZoomingIn ? 0.25 : -0.25;\n            if (this.zoomCurr + addedZoom <= 0 || this.zoomCurr + addedZoom > this.MAX_ALLOWED_ZOOM)\n                return;\n            this.zoomCurr += addedZoom;\n            this.editor.style.scale = `${this.zoomCurr}`;\n            this.zoomRangeInput.value = `${this.zoomCurr}`;\n            this.zoomInput.value = `${this.zoomCurr * 100}`;\n        }\n    }\n    /** @description Handles the zoom with a slider (range input) */\n    handleRangeZoom(e) {\n        const target = e.target;\n        const zoomValue = parseFloat(target.value);\n        this.zoomInput.value = `${zoomValue * 100}`;\n        this.editor.style.scale = `${zoomValue}`;\n    }\n    /** @description Handles the zoom through input */\n    handleInputZoom() {\n        let previousZoom = this.zoomCurr;\n        const zoomAmount = parseInt(this.zoomInput.value, 10) / 100;\n        const minZoom = parseFloat(this.zoomRangeInput.min);\n        this.zoomCurr = zoomAmount >= this.MAX_ALLOWED_ZOOM ? this.MAX_ALLOWED_ZOOM : zoomAmount;\n        if (this.zoomCurr < minZoom) {\n            if (previousZoom < minZoom)\n                previousZoom = 1;\n            this.zoomInput.value = `${previousZoom * 100}`;\n            this.editor.style.scale = `${previousZoom}`;\n            return;\n        }\n        this.zoomInput.value = `${this.zoomCurr * 100}`;\n        this.editor.style.scale = `${this.zoomCurr}`;\n    }\n    /** @description Selects entire input content onfocus */\n    handleInputFocus(inputElement) {\n        inputElement.focus();\n        inputElement.select();\n    }\n    /** @description Enforces digit only input */\n    enforeDigitOnly(e) {\n        if (!/Backspace|\\d/g.test(e.key))\n            e.preventDefault();\n    }\n    /** @description If the title value is invalid, set the document title to \"Unnamed\" */\n    handleTitleBlur() {\n        const content = this.titleInput.value;\n        if (content.replace(/\\s*/g, \"\") !== \"\")\n            return;\n        this.titleInput.value = \"Unnamed\";\n    }\n    /** @description On title change, set document.title */\n    handleTitleInput() {\n        const title = this.titleInput.value;\n        if (title.replace(/\\s*/g, \"\") === \"\") {\n            document.title = \"Azu - Unnamed\";\n        }\n        else {\n            const ellidedString = title.length >= this.MAX_TITLE_LENGTH ? `${title.substring(0, this.MAX_TITLE_LENGTH - 3)}...` : title;\n            document.title = `Azu - ${ellidedString}`;\n        }\n    }\n}\n","/**\n *\n * @description Configures settings\n *\n */\nexport default class Settings {\n    constructor() {\n        this.mainView = document.querySelector(\"#app\");\n        this.settingsButton = document.querySelector(\"#setting-button\");\n        this.settingsView = document.querySelector(\"#settings-view\");\n        this.settingsCloseButton = document.querySelector(\"#close-settings\");\n        this.currentThemeContainer = document.querySelector(\"#current-system-scheme\");\n        this.themesGrid = document.querySelector(\"#settings-apprearance-themes\");\n        this.customThemeInput = document.querySelector(\"#custom-theme-file-input\");\n        this.instantiateSettings();\n    }\n    /** @description Initialises setting options */\n    instantiateSettings() {\n        this.setButtonEvents();\n        this.instantiateThemeSelection();\n    }\n    /** @description sets events relative to opening and closing the settings view */\n    setButtonEvents() {\n        this.settingsButton.addEventListener(\"click\", () => {\n            this.mainView.style.display = \"none\";\n            this.settingsView.style.display = \"block\";\n            document.body.style.overflowY = \"scroll\";\n        });\n        this.settingsCloseButton.addEventListener(\"click\", () => {\n            this.settingsView.style.display = \"none\";\n            this.mainView.style.display = \"block\";\n            document.body.style.overflowY = \"hidden\";\n        });\n    }\n    /** @description Instantiates events related to theme change*/\n    instantiateThemeSelection() {\n        for (const theme of this.themesGrid.children) {\n            const themeContent = theme.getAttribute(\"id\");\n            if (themeContent !== \"custom\") {\n                theme.addEventListener(\"click\", () => {\n                    document.body.setAttribute(\"class\", themeContent);\n                });\n            }\n            else {\n                this.handleCustomThemeInput();\n            }\n        }\n        const colorScheme = window.matchMedia(\"(prefers-color-scheme: dark)\");\n        const detectThemeChange = (e) => {\n            this.currentThemeContainer.textContent = e.matches ? \"dark\" : \"light\";\n        };\n        this.currentThemeContainer.innerText = colorScheme.matches ? \"dark\" : \"light\";\n        colorScheme.addEventListener(\"change\", (e) => detectThemeChange(e));\n    }\n    /** @description Instantiates events for the custom styles input */\n    handleCustomThemeInput() {\n        this.customThemeInput.addEventListener(\"cancel\", () => {\n            console.log(\"Cancelled\");\n        });\n        this.customThemeInput.addEventListener(\"change\", () => {\n            if (!this.customThemeInput.files || this.customThemeInput.files.length === 0)\n                return;\n            const file = this.customThemeInput.files[0];\n            if (file.type !== \"text/css\")\n                return; // not a CSS file\n            const reader = new FileReader();\n            reader.addEventListener(\"load\", (e) => {\n                if (!e || !e.target)\n                    return;\n                const result = e.target.result;\n                const customElementLink = document.querySelector(\"#CustomCSSThemeLink\");\n                if (customElementLink === null) {\n                    const stylesElement = document.createElement(\"link\");\n                    stylesElement.rel = \"stylesheet\";\n                    stylesElement.type = \"text/css\";\n                    stylesElement.href = result;\n                    stylesElement.id = \"CustomCSSThemeLink\";\n                    document.head.appendChild(stylesElement);\n                }\n                else {\n                    const styleElement = customElementLink;\n                    styleElement.setAttribute(\"href\", result);\n                }\n            });\n            reader.readAsDataURL(file);\n        });\n    }\n}\n","/**\n *\n * @description initialises events relative to word count, word length, mistakes,\n * or about the document itself\n *\n **/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nexport default class Statictics {\n    constructor() {\n        this.editor = document.querySelector(\"#editor\");\n        this.statisticsContainer = document.querySelector(\"#statistics-container\");\n        this.statisticsCover = document.querySelector(\"#close-statistics\");\n        this.statisticsView = document.querySelector(\"#statitics-view\");\n        this.wordCountContainer = document.querySelector(\"#word-count\");\n        this.COUNT_INTERVAL = 5000;\n        this.initializeStatistics();\n    }\n    initializeStatistics() {\n        this.wordCountContainer.addEventListener(\"click\", () => this.openStatisticsView());\n        this.statisticsCover.addEventListener(\"click\", () => this.closeStatisticsView());\n        this.configureWordCount();\n    }\n    /** @description Count words at an interval TODO: Fix count*/\n    configureWordCount() {\n        let timer = setTimeout(() => { });\n        this.editor.addEventListener(\"input\", () => {\n            clearTimeout(timer);\n            timer = setTimeout(() => {\n                queueMicrotask(() => {\n                    const textContent = this.editor.innerText;\n                    const textLength = textContent\n                        .trim()\n                        .split(/\\s+/g)\n                        .filter((x) => x !== \"\").length;\n                    this.wordCountContainer.innerText = `${textLength === 0 ? \"No\" : textLength} word${textLength === 1 ? \"\" : \"s\"}`;\n                });\n            }, this.COUNT_INTERVAL);\n        });\n    }\n    /** @description Opens a window related to statistics of the document */\n    openStatisticsView() {\n        this.statisticsView.style.display = \"block\";\n        this.statisticsCover.style.display = \"block\";\n        const content = this.editor.textContent;\n        if (!content) {\n            return; // TODO:\n        }\n        const text = content\n            .replace(/\\s+/g, \" \")\n            .trim()\n            .replace(/\\.|,|:|;|\\(|\\)|\\[|\\]/g, \"\");\n        this.countWords(text).then((words) => {\n            this.computeStatistics(words);\n        });\n    }\n    /** @description Counts words asynchronously since some texts can be large */\n    countWords(text) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const words = text.split(\" \");\n            return words;\n        });\n    }\n    /** @description computes statistics */\n    computeStatistics(words) {\n        const wordCount = words.length;\n        const averageWordLength = words.length === 0 ? 0 : words.join(\"\").length / words.length;\n        const longestTerm = words.reduce((a, b) => (a.length > b.length ? a : b));\n        const distribution = [];\n        const lengthArray = words.map((x) => x.length);\n        for (let i = 1; i < longestTerm.length + 1; i++) {\n            const filteredList = lengthArray.filter((x) => x === i);\n            distribution.push({ [i]: filteredList.length });\n        }\n        const distributionImage = this.drawDistribution(distribution.filter((x) => Object.values(x)[0] !== 0), wordCount, { width: 1000, height: 500 });\n        const statsObj = {\n            wordCount: wordCount,\n            wordAverageLength: parseFloat(averageWordLength.toFixed(2)),\n            wordLengthDistributionImage: distributionImage,\n        };\n        this.displayStatistics(statsObj);\n    }\n    closeStatisticsView() {\n        this.statisticsView.style.display = \"none\";\n        this.statisticsCover.style.display = \"none\";\n    }\n    /** @description draws the distribution on a canvas element used for plotting */\n    drawDistribution(distribution, distributionLength, dimensions) {\n        if (distribution.length === 0)\n            return null;\n        const graph = document.createElement(\"canvas\");\n        const context = graph.getContext(\"2d\");\n        graph.width = dimensions.width;\n        graph.height = dimensions.height;\n        const lineWidth = graph.width * 0.9;\n        const lineHeight = graph.height / 25;\n        const lineX = (graph.width - lineWidth) / 2;\n        const lineY = graph.height * 0.85 - lineHeight / 2;\n        context.fillStyle = \"#ccc\";\n        context.strokeStyle = context.fillStyle;\n        context.fillRect(lineX, lineY, lineWidth, lineHeight);\n        context.strokeRect(lineX, lineY, lineWidth, lineHeight);\n        const barWidth = (lineWidth / distribution.length) * 0.8;\n        const gap = barWidth - barWidth * 0.8;\n        for (let i = 0; i < distribution.length; i++) {\n            const item = distribution[i];\n            const wordLength = parseInt(Object.keys(item)[0]);\n            const barHeight = (Object.values(item)[0] / distributionLength) * (graph.height * 0.65);\n            const barX = barWidth * i + gap * i + lineX;\n            const barY = lineY - barHeight;\n            const fontsize = barWidth / 3 > 64 ? 64 : barWidth / 3;\n            context.font = `${fontsize}px sans-serif`;\n            context.fillStyle = \"#000000\";\n            context.fillText(wordLength.toString(), barX + barWidth / 2 - barWidth / 3 / 2, barY - 10);\n            context.fillStyle = \"#75E19A\";\n            context.fillRect(barX, barY, barWidth, barHeight);\n        }\n        return new URL(graph.toDataURL());\n    }\n    /** @description displays the statistics in a readable manner */\n    displayStatistics(statisticsObject) {\n        this.statisticsContainer.innerHTML = \"\";\n        const statsFrag = document.createDocumentFragment();\n        const statsList = document.createElement(\"ul\");\n        for (const entry of Object.entries(statisticsObject)) {\n            switch (entry[0]) {\n                case \"wordCount\":\n                    {\n                        const wordCount = entry[1];\n                        const li = document.createElement(\"li\");\n                        li.innerText = `Number of words : ${wordCount}`;\n                        statsList.appendChild(li);\n                        console.log(wordCount);\n                    }\n                    break;\n                case \"wordAverageLength\":\n                    {\n                        const averageWordLength = entry[1];\n                        const li = document.createElement(\"li\");\n                        li.innerText = `Average word length : ${averageWordLength}`;\n                        statsList.appendChild(li);\n                        console.log(averageWordLength);\n                    }\n                    break;\n                case \"wordLengthDistributionImage\":\n                    {\n                        if (entry[1] === null)\n                            return;\n                        const imageURL = entry[1];\n                        const li = document.createElement(\"li\");\n                        const span = document.createElement(\"span\");\n                        span.innerText = \"Word length distribution :\";\n                        li.appendChild(span);\n                        const image = new Image(200);\n                        image.src = imageURL.href;\n                        li.appendChild(document.createElement(\"br\"));\n                        li.appendChild(image);\n                        statsList.appendChild(li);\n                    }\n                    break;\n            }\n        }\n        statsFrag.appendChild(statsList);\n        this.statisticsContainer.append(statsFrag);\n    }\n}\n","/**\n *\n * @description Manages the storage, stores some values such as previous session zoom\n *\n **/\nexport default class Storage {\n    constructor() {\n        this.editor = document.querySelector(\"#editor\");\n        this.zoomRangeInput = document.querySelector(\"#zoom-range\");\n        this.zoomInput = document.querySelector(\"#zoom-control-input\");\n        this.zoomAmount = 1;\n        this.instantiateStorage();\n    }\n    /** @description Instatiates all storage methods */\n    instantiateStorage() {\n        this.instantiateLocalStorage();\n    }\n    /** @description Instantiates localStorage */\n    instantiateLocalStorage() {\n        window.addEventListener(\"beforeunload\", () => {\n            const currentSettings = {\n                theme: document.body.getAttribute(\"class\"),\n                lang: document.body.getAttribute(\"lang\"),\n            };\n            localStorage.setItem(\"zoomLevel\", this.zoomInput.value);\n            localStorage.setItem(\"Settings\", JSON.stringify(currentSettings));\n        });\n        document.addEventListener(\"DOMContentLoaded\", () => {\n            const zoomLevel = localStorage.getItem(\"zoomLevel\");\n            if (zoomLevel !== null) {\n                this.zoomAmount = parseInt(zoomLevel, 10);\n                this.zoomRangeInput.value = `${this.zoomAmount / 100}`;\n                this.zoomInput.value = `${this.zoomAmount}`;\n                this.editor.style.scale = `${this.zoomAmount / 100}`;\n            }\n            const fetchedSettings = localStorage.getItem(\"Settings\");\n            if (fetchedSettings === null)\n                return;\n            const settings = JSON.parse(fetchedSettings);\n            for (const [key, value] of Object.entries(settings)) {\n                switch (key) {\n                    case \"theme\":\n                        {\n                            if (value === null)\n                                return;\n                            document.body.setAttribute(\"class\", `${value}`);\n                        }\n                        break;\n                    case \"lang\":\n                        {\n                            if (value === null)\n                                return;\n                            document.body.setAttribute(\"lang\", `${value}`);\n                        }\n                        break;\n                }\n            }\n        });\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n/**\n *\n * @description Implements text correction\n *\n */\nexport default class TextCorrection {\n    constructor() {\n        this.contextMenuOptions = document.querySelector(\"#context-menu-options\");\n        this.contextMenu = document.querySelector(\"#context-menu\");\n        this.contextMenuCover = document.querySelector(\"#main-cover\");\n        this.editor = document.querySelector(\"#editor\");\n        this.currentWordListLang = \"\";\n        this.wordList = [];\n        this.CORRECTION_INTERVAL = 500;\n        this.initializeTextCorrection();\n    }\n    /** @description instantiates all methods related to text correction */\n    initializeTextCorrection() {\n        this.configureTextCorrection();\n    }\n    /** @description Attempts to find errors within the document */\n    configureTextCorrection() {\n        let timer = setTimeout(() => { });\n        this.editor.addEventListener(\"input\", () => {\n            clearTimeout(timer);\n            timer = setTimeout(() => {\n                queueMicrotask(() => __awaiter(this, void 0, void 0, function* () {\n                    if (this.currentWordListLang === \"\" || this.wordList.length === 0) {\n                        this.currentWordListLang = \"french\";\n                        yield this.loadDictionnary(\"french\").then((json) => {\n                            this.setDictionnary(json);\n                        });\n                    }\n                    this.verifyText();\n                }));\n            }, this.CORRECTION_INTERVAL);\n        });\n    }\n    /** @description Loads a specified dictionnary */\n    loadDictionnary(lang) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield fetch(`./json/${lang}.json`);\n            const dictionnary = yield response.json();\n            return dictionnary;\n        });\n    }\n    /** @description sets value this.wordList */\n    setDictionnary(dictionnary) {\n        this.wordList = dictionnary;\n    }\n    /** @description Finds errors in text */\n    verifyText() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.wordList.length === 0)\n                return;\n            let paraIndex = 0;\n            for (const para of this.editor.children) {\n                const textContent = para.textContent;\n                /* Triming a placeholder \\u200B, Zero-width space in order to remove it from tokens */\n                if (textContent === null || textContent.replace(/\\u200B/g, \"\").length === 0) {\n                    paraIndex += 1;\n                    continue;\n                }\n                yield this.scanText(para, paraIndex).then(() => {\n                    paraIndex += 1;\n                });\n            }\n        });\n    }\n    /** @description Scans text content for errors, then structures errors in an object */\n    scanText(paragraph, paraIndex) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const textContent = paragraph.textContent\n                .trim()\n                .replace(/\\u200B/g, \"\")\n                .replace(/\\u00A0/g, \"\");\n            const tokens = textContent.split(\" \");\n            const errorArray = [];\n            switch (this.currentWordListLang) {\n                case \"french\":\n                    {\n                        tokens.forEach((token) => {\n                            const errorTerm = {\n                                paraIndex: paraIndex,\n                                nthOccurence: errorArray.filter((x) => x.term === token || x.paraIndex === paraIndex).length,\n                                term: \"\",\n                            };\n                            const addTerm = (term) => {\n                                Object.defineProperty(errorTerm, \"term\", {\n                                    value: term,\n                                    enumerable: true,\n                                });\n                                errorArray.push(errorTerm);\n                            };\n                            const word = token.includes(\"'\") ? token.split(\"'\") : token;\n                            if (typeof word === \"string\") {\n                                const strWord = word.replace(/[^\\w\\s]+/g, \"\");\n                                /* exclude numbers, decimal numbers, exponential notation, imaginary forms */\n                                if (strWord.match(/(-?\\d+(.\\d+)?((e|E)(\\+|-)\\d+)?i?)(?![a-zA-Z])/g))\n                                    return;\n                                if (this.wordList.includes(strWord.toLowerCase()) || strWord.replace(/\\s+|\\u200B/g, \"\") === \"\")\n                                    return;\n                                addTerm(strWord.trim());\n                            }\n                            else if (Array.isArray(word)) {\n                                /* case for terms composed by elision such as \"c'est\" or \"presqu'le\" */\n                                word.forEach((part, index) => {\n                                    const p = part.replace(/[^\\w\\s]+/g, \"\");\n                                    if (index === 0) {\n                                        /*  \"c'est\" is broken into \"c\" and \"est\", but \"c\" is not a valid term, but by elision, \"ce\" is */\n                                        if (this.wordList.includes((p + \"e\").toLowerCase()))\n                                            return;\n                                        addTerm((p + \"e\").trim());\n                                    }\n                                    else if (!this.wordList.includes(p.toLowerCase())) {\n                                        addTerm(p.trim());\n                                    }\n                                });\n                            }\n                        });\n                        if (errorArray.length === 0)\n                            return;\n                        this.markIncorrectTerm(errorArray);\n                    }\n                    break;\n            }\n        });\n    }\n    /** FIXME: Revert user cursor position on edit */\n    /** @description marks incorrect terms within the DOM, and suggestions along with it */\n    markIncorrectTerm(errorArray) {\n        // \\u200C, \\uFEFF\n        errorArray.forEach((err) => {\n            const paragraph = this.editor.children[err.paraIndex];\n            const termRegex = new RegExp(`\\\\b(${err.term})\\\\b`, \"g\");\n            if (!paragraph.textContent)\n                return;\n            paragraph.textContent = paragraph.textContent.replace(termRegex, \"\\uFEFF$1\\u200C\");\n        });\n        this.editor.innerHTML = this.editor.innerHTML.replace(/\\uFEFF(.*?)\\u200C/g, \"<span data-temp-err>$1</span>\");\n        const errorNodes = document.querySelectorAll(\"[data-temp-err]\");\n        for (const error of errorNodes) {\n            const span = document.createElement(\"span\");\n            span.innerHTML = error.innerHTML;\n            span.setAttribute(\"class\", \"error\");\n            error.replaceWith(span);\n        }\n        /* looping again since looping paragraph by paragraph only preserves the last paragraph's events */\n        const errors = document.getElementsByClassName(\"error\");\n        for (const error of errors) {\n            error.addEventListener(\"contextmenu\", (e) => this.showSuggestions(e));\n            this.observeErrorChange(error);\n        }\n    }\n    /** @description Shows suggestions using the Levensthein distance algorithm */\n    showSuggestions(e) {\n        const span = e.target;\n        const term = span.textContent;\n        if (!term || term.length === 0)\n            return;\n        let filteredList = [];\n        if (term.length <= 3) {\n            filteredList = this.wordList.filter((x) => x.startsWith(term) && x.length < term.length + 2);\n        }\n        else {\n            filteredList = this.wordList.filter((x) => x.startsWith(term.slice(0, 3)));\n        }\n        const accumulator = [];\n        for (const word of filteredList) {\n            const editDistance = this.computeLevenstheinDistance(word, term.toLowerCase());\n            accumulator.push({ word: word, edit: editDistance });\n        }\n        const suggestions = accumulator\n            .sort((a, b) => a.edit - b.edit)\n            .reverse()\n            .slice(0, 3);\n        /* TODO: Wait for contextMenuOptions's children as they might not exist */\n        setTimeout(() => {\n            const errorMessage = document.createElement(\"li\");\n            const suggestionFragment = document.createDocumentFragment();\n            errorMessage.setAttribute(\"id\", \"correction-error-option\");\n            const languageDescriptor = document.createElement(\"h1\");\n            const capitalizedLang = this.currentWordListLang[0].toLocaleUpperCase() + this.currentWordListLang.slice(1);\n            languageDescriptor.innerHTML = capitalizedLang;\n            suggestionFragment.appendChild(languageDescriptor);\n            const suggestionMessage = document.createElement(\"p\");\n            if (suggestions.length === 0) {\n                suggestionMessage.innerHTML = `No suggestions for term \"${term}\"`;\n                suggestionFragment.appendChild(suggestionMessage);\n            }\n            else {\n                const ism = `The spelling for the term \"${term}\" seems incorrect, here are some suggestions :`;\n                suggestionMessage.innerHTML = ism;\n                const suggestionsUL = document.createElement(\"ul\");\n                suggestions.forEach((suggestion) => {\n                    const suggestionLi = document.createElement(\"li\");\n                    suggestionLi.textContent = suggestion.word;\n                    suggestionLi.addEventListener(\"click\", () => {\n                        const textNode = document.createTextNode(suggestion.word);\n                        span.replaceWith(textNode);\n                        this.contextMenu.style.display = \"none\";\n                        this.contextMenuCover.style.display = \"none\";\n                    });\n                    suggestionsUL.appendChild(suggestionLi);\n                });\n                suggestionFragment.appendChild(suggestionMessage);\n                suggestionFragment.appendChild(suggestionsUL);\n            }\n            errorMessage.appendChild(suggestionFragment);\n            const firstChild = this.contextMenuOptions.firstElementChild;\n            const errorJoiner = document.createDocumentFragment();\n            errorJoiner.append(errorMessage, document.createElement(\"hr\"));\n            this.contextMenuOptions.insertBefore(errorJoiner, firstChild);\n        });\n    }\n    /** @description Changes the content of the error element if the updated text is valid */\n    observeErrorChange(error) {\n        const options = {\n            childList: true,\n            characterData: true,\n            characterDataOldValue: true,\n            subtree: true,\n        };\n        const observer = new MutationObserver((mutations) => {\n            for (const mutation of mutations) {\n                const textContent = mutation.target.textContent;\n                if (mutation.type !== \"characterData\" || !textContent)\n                    return;\n                if (this.wordList.includes(textContent)) {\n                    const text = document.createTextNode(textContent);\n                    error.replaceWith(text);\n                }\n            }\n        });\n        observer.observe(error, options);\n    }\n    /**\n     * @description computes Levensthein distance\n     * @see https://rosettacode.org/wiki/Levenshtein_distance#TypeScript\n     */\n    computeLevenstheinDistance(first, second) {\n        const m = first.length, n = second.length;\n        let t = [...Array(n + 1).keys()], u = [];\n        for (let i = 0; i < m; i++) {\n            u = [i + 1];\n            for (let j = 0; j < n; j++) {\n                u[j + 1] = first[i] === second[j] ? t[j] : Math.min(t[j], t[j + 1], u[j]) + 1;\n            }\n            t = u;\n        }\n        return 1 - u[n] / Math.max(m, n);\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n/**\n *\n * @description configurates automatic / manual translations\n *\n */\nexport default class Translations {\n    constructor() {\n        this.editor = document.querySelector(\"#editor\");\n        this.formatBoldButton = document.querySelector(\"#format-bold\");\n        this.formatItalicButton = document.querySelector(\"#format-italics\");\n        this.formatUnderlineButton = document.querySelector(\"#format-underline\");\n        this.formatStrikeButton = document.querySelector(\"#format-strike\");\n        this.settingsAccessibilityTitle = document.querySelector(\"[data-tr-acc]\");\n        this.settingsAppearanceTitle = document.querySelector(\"[data-tr-appearance]\");\n        this.settingsDescription = document.querySelector(\"[data-tr-description]\");\n        this.settingsInterfaceLanguage = document.querySelector(\"[data-tr-intl]\");\n        this.settingsThemesTitle = document.querySelector(\"[data-tr-themes]\");\n        this.settingsThemesDark = document.querySelector(\"[data-tr-th-dark]\");\n        this.settingsThemesLight = document.querySelector(\"[data-tr-th-light]\");\n        this.settingsThemesSystem = document.querySelector(\"[data-tr-th-sys]\");\n        this.settingsThemesCustom = document.querySelector(\"[data-tr-th-cus]\");\n        this.settingsTitle = document.querySelector(\"[data-tr-settings]\");\n        this.titleInput = document.querySelector(\"#title-input\");\n        this.initialContentDiv = document.querySelector(\"#initial-content\");\n        this.languageSelection = document.querySelector(\"#language-options\");\n        this.documentNames = new Set();\n        this.translations = {};\n        this.instantiateTranslations();\n    }\n    /** @description instantiates events for translations */\n    instantiateTranslations() {\n        (() => __awaiter(this, void 0, void 0, function* () {\n            yield this.fetchTranslations().then((json) => {\n                this.translations = json;\n                Object.values(json).forEach((translation) => {\n                    const t = translation;\n                    this.documentNames.add(t.document_initial_title);\n                });\n            });\n            /** this.translations and this.documentNames might not exist yet */\n            this.instantiateLanguageSelection();\n        }))();\n    }\n    /** @description fetches the .json file containing all translations */\n    fetchTranslations() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield fetch(\"./json/translations.json\");\n            const translations = yield response.json().catch((e) => {\n                console.error(e);\n            });\n            return translations;\n        });\n    }\n    /** @description sets the interface language, to the specified value */\n    setInterfaceLanguage(language) {\n        if (Object.keys(this.translations).length === 0 || this.translations[language] === undefined)\n            return;\n        const translationobj = this.translations[language];\n        this.titleInput.placeholder = translationobj.document_no_title_placeholder;\n        if (this.documentNames.has(this.titleInput.value)) {\n            this.titleInput.value = translationobj.document_initial_title;\n            document.title = `Azu - ${translationobj.document_initial_title}`;\n        }\n        /* FIXME: This is very ugly but it works \\_()_/ */\n        this.initialContentDiv.setAttribute(\"data-placeholder\", translationobj.document_place_holder);\n        this.formatBoldButton.children[0].innerHTML = translationobj.format_text_button.bold;\n        this.formatItalicButton.children[0].innerHTML = translationobj.format_text_button.italic;\n        this.formatUnderlineButton.children[0].innerHTML = translationobj.format_text_button.underline;\n        this.formatStrikeButton.children[0].innerHTML = translationobj.format_text_button.strike;\n        this.settingsTitle.textContent = translationobj.settings.title;\n        this.settingsDescription.textContent = translationobj.settings.description;\n        this.settingsAccessibilityTitle.textContent = translationobj.settings.accessibility.title;\n        this.settingsInterfaceLanguage.textContent = translationobj.settings.accessibility.interface_language.title;\n        this.settingsAppearanceTitle.textContent = translationobj.settings.appearance.title;\n        this.settingsThemesTitle.textContent = translationobj.settings.appearance.theme_title;\n        this.settingsThemesLight.textContent = translationobj.settings.appearance.themes.light;\n        this.settingsThemesDark.textContent = translationobj.settings.appearance.themes.dark;\n        this.settingsThemesSystem.querySelector(\"span\").childNodes[0] =\n            translationobj.settings.appearance.themes.system;\n        this.settingsThemesCustom.textContent = translationobj.settings.appearance.themes.custom;\n    }\n    /** @description Allows for the user to change their language */\n    instantiateLanguageSelection() {\n        this.languageSelection.addEventListener(\"change\", () => {\n            const selectedLang = this.languageSelection.children[this.languageSelection.selectedIndex].getAttribute(\"lang\");\n            if (selectedLang === null)\n                return;\n            this.editor.setAttribute(\"lang\", \"zh-hans\");\n            switch (selectedLang) {\n                case \"ja\":\n                    {\n                        this.editor.setAttribute(\"lang\", \"ja\");\n                    }\n                    break;\n                case \"zh-hant\":\n                    {\n                        this.editor.setAttribute(\"lang\", \"zh-hant\");\n                    }\n                    break;\n            }\n            document.body.setAttribute(\"lang\", selectedLang);\n            this.setInterfaceLanguage(selectedLang);\n        });\n    }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport Editor from \"./modules/editor\";\nclass Main {\n    constructor() {\n        this.ini();\n    }\n    /** @description Initializes the App */\n    ini() {\n        this.instantiateServiceWorker();\n        new Editor();\n    }\n    /** @description instantiates a Service worker */\n    instantiateServiceWorker() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!(\"serviceWorker\" in navigator)) {\n                console.error(\"[Service worker] : Service worker not available, please upgrade your browser.\");\n                return;\n            }\n            yield navigator.serviceWorker.register(\"./sw.js\", {\n                scope: \"./src/\",\n            });\n        });\n    }\n}\nnew Main();\n"],"names":[],"sourceRoot":""}